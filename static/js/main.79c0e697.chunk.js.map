{"version":3,"sources":["components/Header.js","modules/Maze.js","modules/MazeAnswer.js","modules/Reducers.js","hooks/useSelectMenu.js","components/Select.js","hooks/useTimer.js","components/Timer.js","hooks/useKeyBoard.js","components/Show.js","components/App.js","reportWebVitals.js","index.js"],"names":["Header","DIRECTIONS","Maze","size","this","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","getKeyArray","key","digGoal","mazeAnswerData","getAnswerRoute","setTimerState","state","goal","answerShow","start","toText","time","initialState","data","answerData","isModalOpen","DEFAULTSIZE","movable","minutes","seconds","milliSeconds","timer","intervalID","squareLength","currentState","createSlice","name","reducers","sizeChange","action","payload","modeChange","setMaze","newMazeData","newAnswerData","clearInterval","openWindow","closeWindow","movePoint","switchMovable","nextX","nextY","isAvailable","showAnswer","startTimer","stopTimer","updateTimer","parseInt","store","configureStore","middleware","getDefaultMiddleware","reducer","SelectModules","useSelector","dispatch","useDispatch","handleSizeChange","actions","handleModeChange","handleSetMaze","update","setInterval","closeModalWindow","getState","close","console","log","resume","openModalWindow","sizeSelect","sizes","selectedSize","filter","selected","className","onChange","event","target","value","map","element","modeSelect","selectedMode","buttons","onClick","handleShowAnswer","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","Select","useSelectMenu","isOpen","onRequestClose","style","contentLabel","overlayClassName","useTimer","handleUseTimer","stop","Timer","useEffect","document","addEventListener","removeEventListener","id","useKeyBoard","getRowStyle","sideLength","padding","height","getRoadStyle","width","lineheight","border","display","boxsizing","keyDownAction","getPayload","rowIndex","colIndex","goalPoint","answerIndex","setMazeStyle","position","mazeWrapperStyle","Show","useRef","useState","setLength","current","clientWidth","mazeStyle","rowStyle","roadStyle","ref","row","point","road","backgroundColor","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.79c0e697.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Header = () => {\n  return <header>迷路ゲーム</header>;\n};\n\nexport default Header;\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport {\n  createSlice,\n  configureStore,\n  getDefaultMiddleware,\n} from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nexport const DEFAULTSIZE = 10;\nexport const DEFAULTMODE = 1;\n\nexport const getKeyArray = (key) => {\n  switch (key) {\n    case \"ArrowUp\":\n      return [-1, 0];\n    case \"ArrowRight\":\n      return [0, 1];\n    case \"ArrowDown\":\n      return [1, 0];\n    case \"ArrowLeft\":\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n};\n\nexport const X = 0;\nexport const Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (\n    (state.xIndex === state.goal[X] && state.yIndex === state.goal[Y]) ||\n    state.isModalOpen === true\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst setTimerState = (state) => {\n  if (\n    (state.goal[X] === state.xIndex && state.goal[Y] === state.yIndex) ||\n    state.answerShow === true\n  ) {\n    return \"finish\";\n  }\n\n  return state.xIndex === state.start[X] && state.yIndex === state.start[Y]\n    ? \"stop\"\n    : \"start\";\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: true,\n  start: [DEFAULTSIZE - 1, 1],\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: \"stop\",\n  intervalID: -1,\n  squareLength: 500,\n};\n\nexport const currentState = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state, action) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        start: [state.size - 1, 1],\n        goal: setGoal(state.size, state.mode, newAnswerData),\n        minutes: \"000\",\n        seconds: \"000\",\n        milliSeconds: \"000\",\n        time: 0,\n        timer: \"stop\",\n        intervalID: -1,\n        // squareLength: action.payload,\n      };\n    },\n    openWindow: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state);\n      if (!movable) {\n        return {\n          ...state,\n        };\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n        isModalOpen: false,\n      };\n    },\n    startTimer: (state, action) => {\n      return {\n        ...state,\n        intervalID: action.payload,\n        timer: \"start\",\n      };\n    },\n    stopTimer: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        intervalID: action.payload,\n        timer: \"finish\",\n      };\n    },\n    updateTimer: (state) => {\n      const time = state.time + 1;\n      const minutes = parseInt((time / 100 / 60) % 100, 10);\n      const seconds = parseInt((time / 100) % 60, 10);\n      const milliSeconds = parseInt(time % 100, 10);\n      return {\n        ...state,\n        minutes: toText(minutes),\n        seconds: toText(seconds),\n        milliSeconds: toText(milliSeconds),\n        time: time,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  middleware: [...getDefaultMiddleware()],\n  reducer: currentState.reducer,\n});\n","import { currentState, store } from \"../modules/Reducers\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nconst SelectModules = () => {\n  const { size, mode, isModalOpen, timer } = useSelector((state) => state);\n  const dispatch = useDispatch();\n  const handleSizeChange = (size) => {\n    const sizeChange = currentState.actions.sizeChange(Number(size));\n    dispatch(sizeChange);\n  };\n  const handleModeChange = (mode) => {\n    const modeChange = currentState.actions.modeChange(Number(mode));\n    dispatch(modeChange);\n  };\n  const handleSetMaze = () => {\n    const setMaze = currentState.actions.setMaze();\n    const update = currentState.actions.updateTimer();\n    const intervalID = setInterval(() => dispatch(update), 10);\n    const start = currentState.actions.startTimer(intervalID);\n    dispatch(setMaze);\n    dispatch(start);\n  };\n  const openModalWindow = () => {\n    const openWindow = currentState.actions.openWindow(true);\n    dispatch(openWindow);\n  };\n  const closeModalWindow = () => {\n    const { timer } = store.getState();\n    const close = timer === \"stop\" ? true : false;\n    const closeWindow = currentState.actions.closeWindow(close);\n    dispatch(closeWindow);\n\n    if (timer === \"start\" || timer === \"pause\") {\n      console.log(timer);\n      const update = currentState.actions.updateTimer();\n      const intervalID = setInterval(() => dispatch(update), 10);\n      const resume = currentState.actions.startTimer(intervalID);\n      dispatch(resume);\n    }\n  };\n  const handleShowAnswer = () => {\n    const showAnswer = currentState.actions.showAnswer(true);\n    dispatch(showAnswer);\n  };\n  const sizeSelect = () => {\n    const sizes = [10, 20, 30, 40, 50];\n    const selectedSize = sizes.filter((selected) => selected === size);\n    return (\n      <select\n        className=\"size-select\"\n        onChange={(event) => handleSizeChange(event.target.value)}\n      >\n        <option value={selectedSize}>\n          {selectedSize} × {selectedSize}\n        </option>\n        {sizes.map((element) => {\n          if (element !== size) {\n            return (\n              <option value={element}>\n                {element} × {element}\n              </option>\n            );\n          }\n        })}\n      </select>\n    );\n  };\n  const modeSelect = () => {\n    const modes = [1, 2];\n    const selectedMode = mode;\n    return (\n      <select\n        className=\"mode\"\n        onChange={(event) => handleModeChange(event.target.value)}\n      >\n        <option value={selectedMode}>\n          {selectedMode === 1 ? \"到達\" : \"最長\"}モード\n        </option>\n        {modes.map((element) => {\n          if (element !== selectedMode) {\n            return (\n              <option value={element}>\n                {element === 1 ? \"到達\" : \"最長\"}モード\n              </option>\n            );\n          }\n        })}\n      </select>\n    );\n  };\n  const buttons = () => {\n    if (timer !== \"stop\") {\n      return (\n        <div>\n          <button onClick={() => handleSetMaze()}>再生成＆スタート</button>\n          <button onClick={() => handleShowAnswer()}>解答</button>\n          <button onClick={() => closeModalWindow()}>閉じる</button>\n        </div>\n      );\n    }\n    return <button onClick={() => handleSetMaze()}>生成＆スタート</button>;\n  };\n  return {\n    size,\n    mode,\n    isModalOpen,\n    handleModeChange,\n    handleSizeChange,\n    openModalWindow,\n    closeModalWindow,\n    sizeSelect,\n    modeSelect,\n    buttons,\n  };\n};\n\nexport default SelectModules;\n","import Modal from \"react-modal\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nconst Select = () => {\n  const {\n    size,\n    mode,\n    isModalOpen,\n    openModalWindow,\n    closeModalWindow,\n    sizeSelect,\n    modeSelect,\n    buttons,\n  } = useSelectMenu();\n\n  return (\n    <div className=\"menu\">\n      <button onClick={() => openModalWindow()}>メニュー</button>\n      <Modal\n        isOpen={isModalOpen}\n        onRequestClose={() => closeModalWindow()}\n        style={windowStyle}\n        contentLabel=\"EXAMPLE\"\n        overlayClassName=\"overlay\"\n      >\n        <h3>迷路オプション</h3>\n        <p> 迷路サイズ・モードを選択してください </p>\n        <ul className=\"list\">\n          <li>迷路サイズ: {sizeSelect()}</li>\n          <li>モード選択: {modeSelect()}</li>\n        </ul>\n        <h4>\n          現在の迷路サイズは{size} × {size}\n        </h4>\n        <h4>{mode === 1 ? \"到達\" : \"最長\"} モードです</h4>\n        <br />\n        {buttons()}\n      </Modal>\n    </div>\n  );\n};\n\nexport default Select;\n","import { currentState, getKeyArray, X, Y } from \"../modules/Reducers\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nconst useTimer = () => {\n  const { xIndex, yIndex, goal, minutes, seconds, milliSeconds } = useSelector(\n    (state) => state\n  );\n  const dispatch = useDispatch();\n\n  const handleUseTimer = (key) => {\n    const nextX = xIndex + getKeyArray(key)[X];\n    const nextY = yIndex + getKeyArray(key)[Y];\n    if (goal[X] === nextX && goal[Y] === nextY) {\n      const stop = currentState.actions.stopTimer(-1);\n      dispatch(stop);\n    }\n  };\n  return {\n    minutes,\n    seconds,\n    milliSeconds,\n    handleUseTimer,\n  };\n};\n\nexport default useTimer;\n","import { useEffect } from \"react\";\nimport useTimer from \"../hooks/useTimer\";\n\nconst Timer = () => {\n  const { minutes, seconds, milliSeconds, handleUseTimer } = useTimer();\n  useEffect(() => {\n    document.addEventListener(\"keydown\", (event) => {\n      handleUseTimer(event.key);\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", (event) => {\n        handleUseTimer(event.key);\n      });\n    };\n  });\n\n  return (\n    <div className=\"timer\">\n      <h5>〈〈 Timer 〉〉</h5>\n      <div id=\"showTimer\">\n        <h5>\n          {minutes} : {seconds} : {milliSeconds}\n        </h5>\n      </div>\n    </div>\n  );\n};\n\nexport default Timer;\n","import { currentState, getKeyArray, X, Y } from \"../modules/Reducers\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nconst getPayload = (key) => {\n  const nextPoint = getKeyArray(key);\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    key: key,\n  };\n};\n\nconst useKeyBoard = () => {\n  const {\n    size,\n    data,\n    answerData,\n    answerShow,\n    squareLength,\n    xIndex,\n    yIndex,\n    goal,\n  } = useSelector((state) => state);\n\n  const dispatch = useDispatch();\n\n  const sideLength = squareLength / size;\n\n  const getRowStyle = (sideLength) => {\n    return {\n      padding: 0,\n      height: sideLength,\n    };\n  };\n\n  const getRoadStyle = (sideLength) => {\n    return {\n      padding: 0,\n      width: sideLength,\n      height: sideLength,\n      lineheight: sideLength,\n      border: \"none\",\n      display: \"inline-block\",\n      boxsizing: \"border-box\",\n    };\n  };\n\n  const movePoint = (rowIndex, colIndex) => {\n    if (rowIndex === xIndex && colIndex === yIndex) {\n      return true;\n    }\n    return false;\n  };\n\n  const goalPoint = (rowIndex, colIndex) => {\n    if (rowIndex === goal[X] && colIndex === goal[Y]) {\n      return true;\n    }\n    return false;\n  };\n\n  const showAnswer = (rowIndex, colIndex) => {\n    if (answerShow === false) {\n      return goalPoint(rowIndex, colIndex) ? true : false;\n    }\n    for (let answerIndex = 0; answerIndex < answerData.length; answerIndex++) {\n      if (\n        answerData[answerIndex][X] === rowIndex &&\n        answerData[answerIndex][Y] === colIndex\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const keyDownAction = (key) => {\n    const payload = getPayload(key);\n    const movePoint = currentState.actions.movePoint(payload);\n    dispatch(movePoint);\n  };\n  return {\n    data,\n    size,\n    getRowStyle,\n    getRoadStyle,\n    keyDownAction,\n    movePoint,\n    showAnswer,\n  };\n};\n\nexport default useKeyBoard;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useKeyBoard from \"../hooks/useKeyBoard\";\n\nconst Show = () => {\n  const {\n    data,\n    size,\n    getRowStyle,\n    getRoadStyle,\n    keyDownAction,\n    movePoint,\n    showAnswer,\n  } = useKeyBoard();\n  const element = useRef(null);\n\n  const [length, setLength] = useState(500);\n\n  useEffect(() => {\n    const squareLength = element.current.clientWidth;\n    setLength(squareLength);\n    console.log(squareLength);\n    document.addEventListener(\"keydown\", (event) => {\n      keyDownAction(event.key);\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", (event) => {\n        keyDownAction(event.key);\n      });\n    };\n  }, []);\n\n  const mazeStyle = setMazeStyle(length);\n  const sideLength = length / size;\n  const rowStyle = getRowStyle(sideLength);\n  const roadStyle = getRoadStyle(sideLength);\n\n  return (\n    <div className=\"show\" ref={element} style={mazeStyle}>\n      <div className=\"maze-wrapper\" style={mazeWrapperStyle}>\n        {data.map((row, rowIndex) => {\n          return (\n            <div style={rowStyle} key={`row:${rowIndex}`}>\n              {row.map((point, colIndex) => {\n                const road = point;\n                return (\n                  <button\n                    key={`row:${rowIndex},col:${colIndex}`}\n                    className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                    style={{\n                      ...roadStyle,\n                      backgroundColor: road\n                        ? showAnswer(rowIndex, colIndex)\n                          ? \"skyblue\"\n                          : \"\"\n                        : \"black\",\n                    }}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nconst setMazeStyle = (length) => {\n  return {\n    position: \"absolute\",\n    top: \"100%\",\n    left: \"50%\",\n    transform: \"translateX(-50%)\",\n    height: \"60%\",\n    width: \"60%\",\n    // \"max-height\": \"500px\",\n    // \"min-height\": `${length}px`,\n    // \"max-width\": \"500px\",\n    // \"min-width\": `${length}px`,\n  };\n};\n\nconst mazeWrapperStyle = {\n  position: \"relative\",\n  height: \"100%\",\n};\n\nexport default Show;\n","import React from \"react\";\nimport Header from \"./Header\";\nimport Select from \"./Select\";\nimport Timer from \"./Timer\";\nimport Show from \"./Show\";\nimport \"../App.css\";\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Header />\n      <Select />\n      <Timer />\n      <Show />\n    </div>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./modules/Reducers\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}