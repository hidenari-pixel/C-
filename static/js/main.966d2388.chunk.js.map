{"version":3,"sources":["Header.js","Timer.js","Show.js","Maze.js","MazeAnswer.js","KeyBoard.js","Select.js","App.js","reportWebVitals.js","index.js"],"names":["Header","React","Component","Timer","props","start","isCounting","incrementer","setInterval","setState","secondsElapsed","state","flag","stop","clearInterval","timerStart","e","keyCode","xIndex","console","log","document","getElementById","innerHTML","componentDidMount","addEventListener","bind","id","rowStyle","height","pointStyle","width","border","display","boxsizing","lineheight","Show","data","this","answerData","answer","showAnswer","rowIndex","colIndex","answerShow","answerIndex","length","className","map","row","style","point","road","yIndex","backgroundColor","DIRECTIONS","Maze","size","xSize","ySize","maze","Array","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","GOAL","createMaze","result","digMaze","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","mode","copyMaze","JSON","parse","stringify","START","allRoutes","pattern","answerRoute","KeyBoard","handleShowMazeAnswer","handleResetMaze","newMazeData","digGoal","newAnswerData","getAnswerRoute","keyDownAction","key","nextXPoint","nextYPoint","componentWillUnmount","removeEventListener","onClick","Select","handleSizeChange","target","value","handleModeChange","prevState","onChange","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.966d2388.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Header extends React.Component {\n  render() {\n    return <header>迷路ゲーム</header>;\n  }\n}\n\nexport default Header;\n","import React from \"react\";\n\nclass Timer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      flag: 0,\n      secondsElapsed: 0,\n    };\n    this.incrementer = null;\n    this.isCounting = false;\n    this.timerStart = this.timerStart.bind(this);\n  }\n\n  start = () => {\n    if (!this.isCounting) {\n      this.incrementer = setInterval(\n        () =>\n          this.setState({\n            secondsElapsed: this.state.secondsElapsed + 0.01,\n            flag: 1,\n          }),\n        10\n      );\n      this.isCounting = true;\n    }\n  };\n\n  stop = () => {\n    clearInterval(this.incrementer);\n    this.isCounting = false;\n  };\n\n  timerStart = (e) => {\n    if (e.keyCode === 38 && this.state.flag === 0) {\n      this.start();\n    } else if (this.props.xIndex === 0) {\n      this.stop();\n    }\n    console.log(this.state.secondsElapsed);\n    document.getElementById(\"showTimer\").innerHTML =\n      \"結果は\" + this.state.secondsElapsed + \"秒です\";\n  };\n\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", this.timerStart);\n  };\n\n  render() {\n    return (\n      <div>\n        <h5>〈〈 Timer 〉〉</h5>\n        <div id=\"showTimer\"></div>\n      </div>\n    );\n  }\n}\n\nexport default Timer;\n","import React from \"react\";\nimport Timer from \"./Timer\";\n\nconst rowStyle = {\n  height: 12,\n};\n\nconst pointStyle = {\n  width: 12,\n  height: 12,\n  border: \"solid 1px gray\",\n  display: \"inline-block\",\n  boxsizing: \"border-box\",\n  lineheight: \"12px\",\n};\n\nconst X = 0;\nconst Y = 1;\n\nclass Show extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    const data = this.props.data;\n    const answerData = this.props.answer;\n    const showAnswer = (rowIndex, colIndex, answerShow) => {\n      if (answerShow === 0) {\n        return false;\n      }\n      for (\n        let answerIndex = 0;\n        answerIndex < answerData.length;\n        answerIndex++\n      ) {\n        if (\n          answerData[answerIndex][X] === rowIndex &&\n          answerData[answerIndex][Y] === colIndex\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    return (\n      <div className=\"Show\">\n        <Timer xIndex={this.props.xIndex} />\n        <div>\n          {data.map((row, rowIndex) => {\n            return (\n              <div style={rowStyle} key={`row:${rowIndex}`}>\n                {row.map((point, colIndex) => {\n                  const road = point;\n                  return (\n                    <button\n                      key={`row:${rowIndex},col:${colIndex}`}\n                      className={\n                        rowIndex === this.props.xIndex &&\n                        colIndex === this.props.yIndex\n                          ? \"start\"\n                          : \"\"\n                      }\n                      style={{\n                        ...pointStyle,\n                        backgroundColor: road\n                          ? showAnswer(\n                              rowIndex,\n                              colIndex,\n                              this.props.answerShow\n                            )\n                            ? \"skyblue\"\n                            : \"\"\n                          : \"black\",\n                      }}\n                    ></button>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Show;\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    let maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    let edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    let nextXIndex = xIndex + DIRECTIONS[direction][X];\n    let nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    let digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    let nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      let directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        let digableDirection = Math.floor(Math.random() * directions.length);\n        let nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        let nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    let nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      let restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal() {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    result[0][this.ySize - 2] = true;\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze, mazeSize) {\n    this.mazeSize = mazeSize;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    let meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    let retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      let nextPoint = this.getAvailableRoads(maze, startPoint);\n      let branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    let copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const START = [this.mazeSize - 2, 1];\n    const GOAL = [1, this.mazeSize - 2];\n    let routes = [];\n    let branchPoints = [];\n    let allRoutes = this.getRoutes(copyMaze, START, routes, branchPoints);\n\n    if (mode === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === GOAL[X] &&\n            allRoutes[pattern][routeIndex][Y] === GOAL[Y]\n          ) {\n            let answerRoute = allRoutes[pattern].slice(0, routeIndex + 1);\n            return answerRoute;\n          }\n        }\n      }\n    }\n\n    if (mode === LONGESTMODE) {\n      let answerRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerRoute.length < allRoutes[pattern].length) {\n          answerRoute = allRoutes[pattern];\n        }\n      }\n      return answerRoute;\n    }\n  }\n}\n","import React from \"react\";\nimport Show from \"./Show\";\nimport Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\n\nconst ON = 1;\nconst OFF = 0;\n\nclass KeyBoard extends React.Component {\n  constructor(props) {\n    super(props);\n    const maze = new Maze(this.props.size);\n    const mazeData = maze.digGoal();\n    const answer = new MazeAnswer(mazeData, this.props.size);\n    const answerData = answer.getAnswerRoute(this.props.mode);\n    this.state = {\n      data: mazeData,\n      answer: answerData,\n      answerShow: OFF,\n      xIndex: this.props.size - 1,\n      yIndex: 1,\n    };\n    this.handleShowMazeAnswer = this.handleShowMazeAnswer.bind(this);\n    this.handleResetMaze = this.handleResetMaze.bind(this);\n    this.keyDownAction = this.keyDownAction.bind(this);\n  }\n\n  handleShowMazeAnswer = () => {\n    if (this.state.answerShow === ON) {\n      this.setState({\n        answerShow: OFF,\n      });\n      return;\n    }\n    this.setState({\n      answerShow: ON,\n    });\n  };\n\n  handleResetMaze = () => {\n    const newMaze = new Maze(this.props.size);\n    const newMazeData = newMaze.digGoal();\n    const newAnswer = new MazeAnswer(newMazeData, this.props.size);\n    const newAnswerData = newAnswer.getAnswerRoute(this.props.mode);\n\n    this.setState({\n      data: newMazeData,\n      answer: newAnswerData,\n      answerShow: OFF,\n      xIndex: this.props.size - 1,\n      yIndex: 1,\n    });\n  };\n\n  keyDownAction = (e) => {\n    let direction = [];\n    if (e.key === \"ArrowUp\" && this.state.xIndex > 0) {\n      direction = [-1, 0];\n    } else if (\n      e.key === \"ArrowRight\" &&\n      this.state.yIndex < this.props.size - 1\n    ) {\n      direction = [0, 1];\n    } else if (\n      e.key === \"ArrowDown\" &&\n      this.state.xIndex < this.props.size - 1\n    ) {\n      direction = [1, 0];\n    } else if (e.key === \"ArrowLeft\" && this.state.yIndex > 0) {\n      direction = [0, -1];\n    } else {\n      direction = [0, 0];\n    }\n\n    const nextXPoint = this.state.xIndex + direction[0];\n    const nextYPoint = this.state.yIndex + direction[1];\n    let nextPoint = [];\n    if (this.state.data[nextXPoint][nextYPoint]) {\n      nextPoint = [nextXPoint, nextYPoint];\n    } else if (!this.state.data[nextXPoint][nextYPoint]) {\n      nextPoint = [this.state.xIndex, this.state.yIndex];\n    }\n    this.setState({\n      xIndex: nextPoint[0],\n      yIndex: nextPoint[1],\n    });\n  };\n\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", this.keyDownAction);\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", this.keyDownAction);\n  };\n\n  render() {\n    return (\n      <div className=\"keyboard\">\n        <button className=\"resetbutton\" onClick={this.handleResetMaze}>\n          作成\n        </button>\n        <Show\n          data={this.state.data}\n          answer={this.state.answer}\n          answerShow={this.state.answerShow}\n          size={this.props.size}\n          xIndex={this.state.xIndex}\n          yIndex={this.state.yIndex}\n        />\n        <h4>\n          モード {this.props.mode}\n          <br />\n          迷路サイズは {this.props.size} × {this.props.size} です\n        </h4>\n        <button className=\"answerbutton\" onClick={this.handleShowMazeAnswer}>\n          迷路の解答\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default KeyBoard;\n","import React from \"react\";\nimport KeyBoard from \"./KeyBoard\";\n\nclass Select extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      size: 10,\n      mode: 1,\n    };\n    this.handleSizeChange = this.handleSizeChange.bind(this);\n    this.handleModeChange = this.handleModeChange.bind(this);\n  }\n\n  handleSizeChange = (e) => {\n    this.setState({\n      size: e.target.value,\n    });\n  };\n\n  handleModeChange = (e) => {\n    this.setState((prevState) => {\n      prevState.mode = e.target.value;\n      return { mode: prevState.mode };\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <h3>迷路オプション</h3>\n        <ul className=\"list\">\n          <li>\n            迷路サイズ:{\" \"}\n            <select className=\"selectSize\" onChange={this.handleSizeChange}>\n              <option value=\"\">--サイズ選択--</option>\n              <option value=\"10\">10 × 10</option>\n              <option value=\"20\">20 × 20</option>\n              <option value=\"30\">30 × 30</option>\n              <option value=\"40\">40 × 40</option>\n              <option value=\"50\">50 × 50</option>\n            </select>\n          </li>\n          <li>\n            モード選択:{\" \"}\n            <select className=\"selectMode\" onChange={this.handleModeChange}>\n              <option value=\"\">--モードを選択--</option>\n              <option value=\"1\">到達モード ⇨ モード1</option>\n              <option value=\"2\">最長モード　→　モード2</option>\n            </select>\n          </li>\n        </ul>\n        <br />\n        <KeyBoard size={this.state.size} mode={this.state.mode} />\n      </div>\n    );\n  }\n}\n\nexport default Select;\n","import React from \"react\";\nimport Select from \"./Select\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Select />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Header from \"./Header\";\nimport App from \"./App\";\n\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Header />\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}