{"version":3,"sources":["Header.js","Show.js","Timer.js","Maze.js","MazeAnswer.js","KeyBoard.js","Select.js","App.js","reportWebVitals.js","index.js"],"names":["Header","React","Component","rowStyle","height","roadStyle","width","border","display","boxsizing","lineheight","Show","props","data","this","answerData","answer","movePoint","rowIndex","colIndex","xIndex","yIndex","showAnswer","answerShow","goal","goalPoint","answerIndex","length","className","map","row","style","point","road","backgroundColor","Timer","start","state","timer","setInterval","update","setState","stop","clearInterval","time","minutes","parseInt","seconds","milliSeconds","toText","slice","timerUse","componentDidMount","document","addEventListener","componentWillUnmount","removeEventListener","bind","id","size","DIRECTIONS","Maze","xSize","ySize","maze","Array","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","START","allRoutes","pattern","answerLongestRoute","keyArray","ArrowUp","ArrowRight","ArrowDown","ArrowLeft","KeyBoard","handleShowMazeAnswer","handleResetMaze","newMazeData","digGoal","newAnswerData","getAnswerRoute","keyDownAction","e","movable","Object","keys","includes","key","nextXPoint","nextYPoint","mazeGoal","onClick","Select","handleSizeChange","target","value","handleModeChange","onChange","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.24d39e01.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Header extends React.Component {\n  render() {\n    return <header>迷路ゲーム</header>;\n  }\n}\n\nexport default Header;\n","import React from \"react\";\n\nconst rowStyle = {\n  height: 12,\n};\n\nconst roadStyle = {\n  width: 12,\n  height: 12,\n  border: \"solid 1px gray\",\n  display: \"inline-block\",\n  boxsizing: \"border-box\",\n  lineheight: \"12px\",\n};\n\nconst X = 0;\nconst Y = 1;\n\nclass Show extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    const data = this.props.data;\n    const answerData = this.props.answer;\n    const movePoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.xIndex && colIndex === this.props.yIndex) {\n        return true;\n      }\n      return false;\n    };\n\n    const goalPoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.goal[X] && colIndex === this.props.goal[Y]) {\n        return true;\n      }\n      return false;\n    };\n\n    const showAnswer = (rowIndex, colIndex, answerShow) => {\n      if (answerShow === 0) {\n        return goalPoint(rowIndex, colIndex) ? true : false;\n      }\n      for (\n        let answerIndex = 0;\n        answerIndex < answerData.length;\n        answerIndex++\n      ) {\n        if (\n          answerData[answerIndex][X] === rowIndex &&\n          answerData[answerIndex][Y] === colIndex\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    return (\n      <div className=\"Show\">\n        <div>\n          {data.map((row, rowIndex) => {\n            return (\n              <div style={rowStyle} key={`row:${rowIndex}`}>\n                {row.map((point, colIndex) => {\n                  const road = point;\n                  return (\n                    <button\n                      key={`row:${rowIndex},col:${colIndex}`}\n                      className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                      // スタイルの実装を考え直せ\n                      style={{\n                        ...roadStyle,\n                        backgroundColor: road\n                          ? showAnswer(\n                              rowIndex,\n                              colIndex,\n                              this.props.answerShow\n                            )\n                            ? \"skyblue\"\n                            : \"\"\n                          : \"black\",\n                      }}\n                    ></button>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Show;\n","import React from \"react\";\nimport Show from \"./Show\";\n\nclass Timer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      minutes: \"000\",\n      seconds: \"000\",\n      milliSeconds: \"000\",\n      time: 0,\n      timer: \"\",\n    };\n    this.timerUse = this.timerUse.bind(this);\n  }\n\n  start = () => {\n    if (this.state.timer !== \"stop\") {\n      this.timer = setInterval(() => this.update(), 10);\n      this.setState({\n        timer: \"start\",\n      });\n    }\n  };\n\n  stop = () => {\n    clearInterval(this.timer);\n    if (this.state.timer === \"pause\") {\n      this.setState({\n        timer: \"start\",\n      });\n      return;\n    }\n    if (this.state.timer !== \"stop\") {\n      this.setState({\n        timer: \"pause\",\n      });\n    }\n  };\n\n  update = () => {\n    const time = this.state.time + 1;\n    const minutes = parseInt((time / 100 / 60) % 100, 10);\n    const seconds = parseInt((time / 100) % 60, 10);\n    const milliSeconds = parseInt(time % 100, 10);\n    this.setState({\n      minutes: this.toText(minutes),\n      seconds: this.toText(seconds),\n      milliSeconds: this.toText(milliSeconds),\n      time: time,\n    });\n  };\n\n  toText = (time) => {\n    return (\"000\" + time).slice(-3);\n  };\n\n  timerUse = () => {\n    if (this.state.timer === \"\") {\n      this.start();\n      this.setState({\n        timer: \"start\",\n      });\n    }\n    if (this.props.xIndex === 0) {\n      this.stop();\n      this.setState({\n        timer: \"stop\",\n      });\n    }\n  };\n\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", this.timerUse);\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", this.timerUse);\n  };\n\n  render() {\n    return (\n      <div>\n        <h5>〈〈 Timer 〉〉</h5>\n        <div id=\"showTimer\">\n          <h5>\n            {this.state.minutes} : {this.state.seconds} :{\" \"}\n            {this.state.milliSeconds}\n          </h5>\n        </div>\n        <Show\n          data={this.props.data}\n          answer={this.props.answer}\n          answerShow={this.props.answerShow}\n          size={this.props.size}\n          xIndex={this.props.xIndex}\n          yIndex={this.props.yIndex}\n          timer={this.state.timer}\n          goal={this.props.goal}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Timer;\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze, mazeSize) {\n    this.mazeSize = mazeSize;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const START = [this.mazeSize - 2, 1];\n    const GOAL = [1, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(copyMaze, START, routes, branchPoints);\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === GOAL[X] &&\n            allRoutes[pattern][routeIndex][Y] === GOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import React from \"react\";\nimport Timer from \"./Timer\";\nimport Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\n\nconst ON = 1;\nconst OFF = 0;\n\nconst REACHMODE = 1;\n\nconst X = 0;\nconst Y = 1;\n\nconst keyArray = {\n  ArrowUp: [-1, 0],\n  ArrowRight: [0, 1],\n  ArrowDown: [1, 0],\n  ArrowLeft: [0, -1],\n};\n\nclass KeyBoard extends React.Component {\n  constructor(props) {\n    super(props);\n    const maze = new Maze(this.props.size);\n    const mazeData = maze.digGoal(this.props.mode);\n    const answer = new MazeAnswer(mazeData, this.props.size);\n    const answerData = answer.getAnswerRoute(this.props.mode);\n    const mazeGoal = [answerData.slice(-1)[0][X], answerData.slice(-1)[0][Y]];\n    this.state = {\n      data: mazeData,\n      answer: answerData,\n      answerShow: OFF,\n      xIndex: this.props.size - 1,\n      yIndex: 1,\n      movable: ON,\n      goal:\n        this.props.mode === REACHMODE\n          ? [0, this.props.size - 2]\n          : [mazeGoal[X], mazeGoal[Y]],\n    };\n    this.handleShowMazeAnswer = this.handleShowMazeAnswer.bind(this);\n    this.handleResetMaze = this.handleResetMaze.bind(this);\n    this.keyDownAction = this.keyDownAction.bind(this);\n  }\n\n  handleShowMazeAnswer = () => {\n    if (this.state.answerShow === ON) {\n      this.setState({\n        answerShow: OFF,\n      });\n      return;\n    }\n    this.setState({\n      answerShow: ON,\n    });\n  };\n\n  handleResetMaze = () => {\n    const newMaze = new Maze(this.props.size);\n    const newMazeData = newMaze.digGoal(this.props.mode);\n    const newAnswer = new MazeAnswer(newMazeData, this.props.size);\n    const newAnswerData = newAnswer.getAnswerRoute(this.props.mode);\n    const newMazeGoal = () => {\n      if (Number(this.props.mode) === REACHMODE) {\n        return [0, this.props.size - 2];\n      }\n      return [newAnswerData.slice(-1)[0][X], newAnswerData.slice(-1)[0][Y]];\n    };\n\n    this.setState({\n      data: newMazeData,\n      answer: newAnswerData,\n      answerShow: OFF,\n      xIndex: this.props.size - 1,\n      yIndex: 1,\n      goal: newMazeGoal(),\n    });\n  };\n\n  keyDownAction = (e) => {\n    let direction = [];\n    if (this.state.movable === ON) {\n      if (Object.keys(keyArray).includes(e.key)) {\n        direction = keyArray[e.key];\n      } else {\n        // ここのelse消したい\n        direction = [0, 0];\n      }\n      if (this.state.xIndex === this.props.size - 1 && e.key !== \"ArrowUp\") {\n        direction = [0, 0];\n      }\n      const nextXPoint = this.state.xIndex + direction[X];\n      const nextYPoint = this.state.yIndex + direction[Y];\n      if (this.state.data[nextXPoint][nextYPoint]) {\n        this.setState({\n          xIndex: nextXPoint,\n          yIndex: nextYPoint,\n        });\n      }\n    }\n    if (\n      this.state.xIndex === this.state.goal[X] &&\n      this.state.yIndex === this.state.goal[Y]\n    ) {\n      this.setState({\n        movable: OFF,\n      });\n    }\n  };\n\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", this.keyDownAction);\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", this.keyDownAction);\n  };\n\n  render() {\n    return (\n      <div className=\"keyboard\">\n        <button className=\"resetbutton\" onClick={this.handleResetMaze}>\n          作成\n        </button>\n        <Timer\n          data={this.state.data}\n          answer={this.state.answer}\n          answerShow={this.state.answerShow}\n          size={this.props.size}\n          xIndex={this.state.xIndex}\n          yIndex={this.state.yIndex}\n          goal={this.state.goal}\n        />\n        <h4>\n          モード {this.props.mode}\n          <br />\n          迷路サイズは {this.props.size} × {this.props.size} です\n        </h4>\n        <button className=\"answerbutton\" onClick={this.handleShowMazeAnswer}>\n          迷路の解答\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default KeyBoard;\n","import React from \"react\";\nimport KeyBoard from \"./KeyBoard\";\n\nclass Select extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      size: 10,\n      mode: 1,\n    };\n    this.handleSizeChange = this.handleSizeChange.bind(this);\n    this.handleModeChange = this.handleModeChange.bind(this);\n  }\n\n  handleSizeChange = (e) => {\n    this.setState({\n      size: e.target.value,\n    });\n  };\n\n  handleModeChange = (e) => {\n    this.setState({\n      mode: e.target.value,\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <h3>迷路オプション</h3>\n        <ul className=\"list\">\n          <li>\n            迷路サイズ:{\" \"}\n            <select className=\"selectSize\" onChange={this.handleSizeChange}>\n              <option value=\"\">--サイズ選択--</option>\n              <option value=\"10\">10 × 10</option>\n              <option value=\"20\">20 × 20</option>\n              <option value=\"30\">30 × 30</option>\n              <option value=\"40\">40 × 40</option>\n              <option value=\"50\">50 × 50</option>\n            </select>\n          </li>\n          <li>\n            モード選択:{\" \"}\n            <select className=\"selectMode\" onChange={this.handleModeChange}>\n              <option value=\"\">--モードを選択--</option>\n              <option value=\"1\">到達モード ⇨ モード1</option>\n              <option value=\"2\">最長モード　→　モード2</option>\n            </select>\n          </li>\n        </ul>\n        <br />\n        <KeyBoard size={this.state.size} mode={this.state.mode} />\n      </div>\n    );\n  }\n}\n\nexport default Select;\n","import React from \"react\";\nimport Select from \"./Select\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Select />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Header from \"./Header\";\nimport App from \"./App\";\n\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Header />\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}