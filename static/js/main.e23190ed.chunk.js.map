{"version":3,"sources":["components/Header.js","modules/Maze.js","modules/MazeAnswer.js","modules/Reducers.js","hooks/useSelectMenu.js","components/Select.js","hooks/useTimer.js","components/Timer.js","hooks/useKeyBoard.js","components/Show.js","hooks/useSPButton.js","components/SPDisplay.js","components/App.js","reportWebVitals.js","index.js"],"names":["Header","DIRECTIONS","Maze","size","this","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","getKeyArray","key","digGoal","mazeAnswerData","getAnswerRoute","setTimerState","state","goal","answerShow","start","toText","time","initialState","data","answerData","isModalOpen","DEFAULTSIZE","movable","minutes","seconds","milliSeconds","timer","intervalID","squareLength","currentState","createSlice","name","reducers","sizeChange","action","payload","modeChange","setMaze","newMazeData","newAnswerData","clearInterval","openWindow","closeWindow","movePoint","switchMovable","nextX","nextY","isAvailable","showAnswer","startTimer","updateTimer","parseInt","store","configureStore","reducer","Button","styled","button","SelectModules","useSelector","dispatch","useDispatch","handleSizeChange","actions","handleModeChange","handleSetMaze","update","setInterval","closeModalWindow","getState","close","resume","openModalWindow","sizeSelect","sizes","selectedSize","filter","selected","className","onChange","event","target","value","map","element","modeSelect","selectedMode","buttons","onClick","handleShowAnswer","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","MenuButtonWrapper","Select","useSelectMenu","isOpen","onRequestClose","style","contentLabel","overlayClassName","useTimer","TimerWrapper","div","Timer","useKeyBoard","keyDownAction","getPayload","rowIndex","colIndex","goalPoint","answerIndex","MazeWrapper","props","height","Show","useRef","useState","setLength","useEffect","current","clientWidth","document","addEventListener","removeEventListener","sideLength","rowStyle","padding","roadStyle","width","lineheight","border","display","boxsizing","ref","row","point","road","backgroundColor","useSPButton","buttonAction","SPDisplayWrapper","ButtonWrapper","UpButton","RightButton","DownButton","LeftButton","SPDisplay","query","onPointerDown","AppWrapper","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e23190ed.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Header = () => {\n  return <header>迷路ゲーム</header>;\n};\n\nexport default Header;\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport { createSlice, configureStore } from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nexport const DEFAULTSIZE = 10;\nexport const DEFAULTMODE = 1;\n\nexport const getKeyArray = (key) => {\n  switch (key) {\n    case \"ArrowUp\":\n      return [-1, 0];\n    case \"ArrowRight\":\n      return [0, 1];\n    case \"ArrowDown\":\n      return [1, 0];\n    case \"ArrowLeft\":\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n};\n\nexport const X = 0;\nexport const Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (\n    (state.xIndex === state.goal[X] && state.yIndex === state.goal[Y]) ||\n    state.isModalOpen === true\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst setTimerState = (state) => {\n  if (\n    (state.goal[X] === state.xIndex && state.goal[Y] === state.yIndex) ||\n    state.answerShow === true\n  ) {\n    return \"finish\";\n  }\n\n  return state.xIndex === state.start[X] && state.yIndex === state.start[Y]\n    ? \"stop\"\n    : \"start\";\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: true,\n  start: [DEFAULTSIZE - 1, 1],\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: \"stop\",\n  intervalID: -1,\n  squareLength: 500,\n};\n\nexport const currentState = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        start: [state.size - 1, 1],\n        goal: setGoal(state.size, state.mode, newAnswerData),\n        minutes: \"000\",\n        seconds: \"000\",\n        milliSeconds: \"000\",\n        time: 0,\n        timer: \"stop\",\n        intervalID: -1,\n      };\n    },\n    openWindow: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state);\n      if (!movable) {\n        clearInterval(state.intervalID);\n        return {\n          ...state,\n        };\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      if (nextPoint[X] === state.goal[X] && nextPoint[Y] === state.goal[Y]) {\n        clearInterval(state.intervalID);\n        return {\n          ...state,\n          xIndex: nextPoint[X],\n          yIndex: nextPoint[Y],\n          movable: movable,\n          intervalID: -1,\n          timer: \"finish\",\n        };\n      }\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n        isModalOpen: false,\n      };\n    },\n    startTimer: (state, action) => {\n      return {\n        ...state,\n        intervalID: action.payload,\n        timer: \"start\",\n      };\n    },\n    updateTimer: (state) => {\n      const time = state.time + 1;\n      const minutes = parseInt((time / 100 / 60) % 100, 10);\n      const seconds = parseInt((time / 100) % 60, 10);\n      const milliSeconds = parseInt(time % 100, 10);\n      return {\n        ...state,\n        minutes: toText(minutes),\n        seconds: toText(seconds),\n        milliSeconds: toText(milliSeconds),\n        time: time,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  reducer: currentState.reducer,\n});\n","import { currentState, store } from \"../modules/Reducers\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport styled from \"styled-components\";\n\nconst SelectModules = () => {\n  const { size, mode, isModalOpen, timer } = useSelector((state) => state);\n  const dispatch = useDispatch();\n\n  const handleSizeChange = (size) => {\n    const sizeChange = currentState.actions.sizeChange(Number(size));\n    dispatch(sizeChange);\n  };\n\n  const handleModeChange = (mode) => {\n    const modeChange = currentState.actions.modeChange(Number(mode));\n    dispatch(modeChange);\n  };\n\n  const handleSetMaze = () => {\n    const setMaze = currentState.actions.setMaze();\n    const update = currentState.actions.updateTimer();\n    const intervalID = setInterval(() => dispatch(update), 10);\n    const start = currentState.actions.startTimer(intervalID);\n    dispatch(setMaze);\n    dispatch(start);\n  };\n\n  const openModalWindow = () => {\n    const openWindow = currentState.actions.openWindow(true);\n    dispatch(openWindow);\n  };\n\n  const closeModalWindow = () => {\n    const { timer } = store.getState();\n    const close = timer === \"stop\" ? true : false;\n    const closeWindow = currentState.actions.closeWindow(close);\n    dispatch(closeWindow);\n\n    if (timer === \"start\" || timer === \"pause\") {\n      const update = currentState.actions.updateTimer();\n      const intervalID = setInterval(() => dispatch(update), 10);\n      const resume = currentState.actions.startTimer(intervalID);\n      dispatch(resume);\n    }\n  };\n\n  const handleShowAnswer = () => {\n    const showAnswer = currentState.actions.showAnswer(true);\n    dispatch(showAnswer);\n  };\n\n  const sizeSelect = () => {\n    const sizes = [10, 20, 30, 40, 50];\n    const selectedSize = sizes.filter((selected) => selected === size);\n    return (\n      <select\n        className=\"size-select\"\n        onChange={(event) => handleSizeChange(event.target.value)}\n      >\n        <option value={selectedSize}>\n          {selectedSize} × {selectedSize}\n        </option>\n        {sizes.map((element) => {\n          if (element !== size) {\n            return (\n              <option value={element} key={element}>\n                {element} × {element}\n              </option>\n            );\n          }\n        })}\n      </select>\n    );\n  };\n\n  const modeSelect = () => {\n    const modes = [1, 2];\n    const selectedMode = mode;\n    return (\n      <select\n        className=\"mode\"\n        onChange={(event) => handleModeChange(event.target.value)}\n      >\n        <option value={selectedMode}>\n          {selectedMode === 1 ? \"到達\" : \"最長\"}モード\n        </option>\n        {modes.map((element) => {\n          if (element !== selectedMode) {\n            return (\n              <option value={element} key={element}>\n                {element === 1 ? \"到達\" : \"最長\"}モード\n              </option>\n            );\n          }\n        })}\n      </select>\n    );\n  };\n\n  const buttons = () => {\n    if (timer !== \"stop\") {\n      return (\n        <div>\n          <Button onClick={() => handleSetMaze()}>再生成＆スタート</Button>\n          <Button onClick={() => handleShowAnswer()}>解答</Button>\n          <Button onClick={() => closeModalWindow()}>閉じる</Button>\n        </div>\n      );\n    }\n    return <Button onClick={() => handleSetMaze()}>生成＆スタート</Button>;\n  };\n\n  return {\n    size,\n    mode,\n    isModalOpen,\n    handleModeChange,\n    handleSizeChange,\n    openModalWindow,\n    closeModalWindow,\n    sizeSelect,\n    modeSelect,\n    buttons,\n  };\n};\n\nconst Button = styled.button`\n  & {\n    display: inline-block;\n    width: 40%;\n    height: 30px;\n    text-align: center;\n    text-decoration: none;\n    line-height: 100%;\n    outline: none;\n    background-color: #333;\n    color: #fff;\n    border: none;\n    white-space: nowrap;\n    margin: 3px;\n  }\n  ::before,\n  ::after {\n    position: absolute;\n    z-index: -1;\n    display: block;\n    content: \"\";\n  }\n  &,\n  ::before,\n  ::after {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    -webkit-transition: all 0.3s;\n    transition: all 0.3s;\n  }\n  :hover {\n    background-color: #59b1eb;\n  }\n`;\n\nexport default SelectModules;\n","import Modal from \"react-modal\";\nimport styled from \"styled-components\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nconst Select = () => {\n  const {\n    size,\n    mode,\n    isModalOpen,\n    openModalWindow,\n    closeModalWindow,\n    sizeSelect,\n    modeSelect,\n    buttons,\n  } = useSelectMenu();\n\n  return (\n    <div className=\"menu\">\n      <MenuButtonWrapper onClick={() => openModalWindow()}>\n        メニュー\n      </MenuButtonWrapper>\n      <Modal\n        isOpen={isModalOpen}\n        onRequestClose={() => closeModalWindow()}\n        style={windowStyle}\n        contentLabel=\"EXAMPLE\"\n        overlayClassName=\"overlay\"\n      >\n        <h3>迷路オプション</h3>\n        <p> 迷路サイズ・モードを選択してください </p>\n        <ul className=\"list\">\n          <li>迷路サイズ: {sizeSelect()}</li>\n          <li>モード選択: {modeSelect()}</li>\n        </ul>\n        <h4>\n          現在の迷路サイズは{size} × {size}\n        </h4>\n        <h4>{mode === 1 ? \"到達\" : \"最長\"} モードです</h4>\n        <br />\n        {buttons()}\n      </Modal>\n    </div>\n  );\n};\n\nconst MenuButtonWrapper = styled.button`\n   {\n    width: 30%;\n    height: 20%;\n    color: grey;\n    background-color: skyblue;\n    font-size: 20px;\n    font-weight: 0;\n    text-decoration: none;\n    transition: 0.3s;\n    border-color: skyblue;\n  }\n  :hover {\n    color: #f2f2f2;\n  }\n`;\n\nexport default Select;\n","import { useSelector } from \"react-redux\";\n\nconst useTimer = () => {\n  const { minutes, seconds, milliSeconds } = useSelector((state) => state);\n\n  return {\n    minutes,\n    seconds,\n    milliSeconds,\n  };\n};\n\nexport default useTimer;\n","import styled from \"styled-components\";\nimport useTimer from \"../hooks/useTimer\";\n\nconst Timer = () => {\n  const { minutes, seconds, milliSeconds } = useTimer();\n\n  return (\n    <TimerWrapper>\n      <h5>\n        {minutes} : {seconds} : {milliSeconds}\n      </h5>\n    </TimerWrapper>\n  );\n};\n\nconst TimerWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n`;\n\nexport default Timer;\n","import { currentState, getKeyArray, X, Y } from \"../modules/Reducers\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nconst getPayload = (key) => {\n  const nextPoint = getKeyArray(key);\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    key: key,\n  };\n};\n\nconst useKeyBoard = () => {\n  const { size, data, answerData, answerShow, xIndex, yIndex, goal } =\n    useSelector((state) => state);\n\n  const dispatch = useDispatch();\n\n  const movePoint = (rowIndex, colIndex) => {\n    if (rowIndex === xIndex && colIndex === yIndex) {\n      return true;\n    }\n    return false;\n  };\n\n  const goalPoint = (rowIndex, colIndex) => {\n    if (rowIndex === goal[X] && colIndex === goal[Y]) {\n      return true;\n    }\n    return false;\n  };\n\n  const showAnswer = (rowIndex, colIndex) => {\n    if (answerShow === false) {\n      return goalPoint(rowIndex, colIndex) ? true : false;\n    }\n    for (let answerIndex = 0; answerIndex < answerData.length; answerIndex++) {\n      if (\n        answerData[answerIndex][X] === rowIndex &&\n        answerData[answerIndex][Y] === colIndex\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const keyDownAction = (key) => {\n    const payload = getPayload(key);\n    const movePoint = currentState.actions.movePoint(payload);\n    dispatch(movePoint);\n  };\n  return {\n    data,\n    size,\n    keyDownAction,\n    movePoint,\n    showAnswer,\n  };\n};\n\nexport default useKeyBoard;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useKeyBoard from \"../hooks/useKeyBoard\";\nimport styled from \"styled-components\";\n\nconst Show = () => {\n  const { data, size, keyDownAction, movePoint, showAnswer } = useKeyBoard();\n  const element = useRef(null);\n  const [length, setLength] = useState(0);\n  useEffect(() => {\n    const squareLength = element.current.clientWidth;\n    setLength(squareLength);\n    document.addEventListener(\"keydown\", (event) => {\n      keyDownAction(event.key);\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", (event) => {\n        keyDownAction(event.key);\n      });\n    };\n  }, []);\n\n  const sideLength = length / size;\n  const rowStyle = {\n    padding: 0,\n    height: sideLength,\n  };\n  const roadStyle = {\n    padding: 0,\n    width: sideLength,\n    height: sideLength,\n    lineheight: sideLength,\n    border: \"none\",\n    display: \"inline-block\",\n    boxsizing: \"border-box\",\n  };\n\n  return (\n    <MazeWrapper ref={element} height={length}>\n      {data.map((row, rowIndex) => {\n        return (\n          <div style={rowStyle} key={`row:${rowIndex}`}>\n            {row.map((point, colIndex) => {\n              const road = point;\n              return (\n                <button\n                  key={`row:${rowIndex},col:${colIndex}`}\n                  className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                  style={{\n                    ...roadStyle,\n                    backgroundColor: road\n                      ? showAnswer(rowIndex, colIndex)\n                        ? \"skyblue\"\n                        : \"\"\n                      : \"black\",\n                  }}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </MazeWrapper>\n  );\n};\n\nconst MazeWrapper = styled.div`\n  position: absolute;\n  top: 25%;\n  left: 50%;\n  transform: translateX(-50%);\n  min-width: 40%;\n  height: ${(props) => props.height}px;\n`;\n\nexport default Show;\n","import { useDispatch } from \"react-redux\";\nimport { currentState, getKeyArray, X, Y } from \"../modules/Reducers\";\n\nconst useSPButton = () => {\n  const dispatch = useDispatch();\n\n  const buttonAction = (key) => {\n    const nextPoint = getKeyArray(key);\n    const payload = {\n      nextX: nextPoint[X],\n      nextY: nextPoint[Y],\n      key: key,\n    };\n    const movePoint = currentState.actions.movePoint(payload);\n    dispatch(movePoint);\n  };\n  return {\n    buttonAction,\n  };\n};\n\nexport default useSPButton;\n","import MediaQuery from \"react-responsive\";\nimport useSPButton from \"../hooks/useSPButton\";\nimport styled from \"styled-components\";\n\nconst SPDisplay = () => {\n  const { buttonAction } = useSPButton();\n  return (\n    <SPDisplayWrapper>\n      <MediaQuery query=\"(max-width: 568px)\">\n        <ButtonWrapper>\n          <UpButton onPointerDown={() => buttonAction(\"ArrowUp\")}></UpButton>\n          <RightButton\n            onPointerDown={() => buttonAction(\"ArrowRight\")}\n          ></RightButton>\n          <DownButton\n            onPointerDown={() => buttonAction(\"ArrowDown\")}\n          ></DownButton>\n          <LeftButton\n            onPointerDown={() => buttonAction(\"ArrowLeft\")}\n          ></LeftButton>\n        </ButtonWrapper>\n      </MediaQuery>\n    </SPDisplayWrapper>\n  );\n};\n\nconst SPDisplayWrapper = styled.div`\n  position: absolute;\n  bottom: 43%;\n  right: 60%;\n  display: flex;\n`;\n\nconst ButtonWrapper = styled.div`\n  position: relative;\n`;\n\nconst Button = styled.div`\n  border-right: 25px solid transparent;\n  border-bottom: 50px solid #00ecff;\n  border-left: 25px solid transparent;\n`;\n\nconst UpButton = styled(Button)`\n  position: absolute;\n  top: 0;\n  left: 0;\n`;\n\nconst RightButton = styled(Button)`\n  position: absolute;\n  top: 50px;\n  left: 50px;\n  transform: rotate(90deg);\n`;\n\nconst DownButton = styled(Button)`\n  position: absolute;\n  top: 100px;\n  left: 0px;\n  transform: rotate(180deg);\n`;\n\nconst LeftButton = styled(Button)`\n  position: absolute;\n  top: 50px;\n  left: -50px;\n  transform: rotate(270deg);\n`;\n\nexport default SPDisplay;\n","import React from \"react\";\nimport Header from \"./Header\";\nimport Select from \"./Select\";\nimport Timer from \"./Timer\";\nimport Show from \"./Show\";\nimport SPDisplay from \"./SPDisplay\";\nimport \"../App.css\";\nimport styled from \"styled-components\";\n\nconst App = () => {\n  return (\n    <AppWrapper>\n      <Header />\n      <Select />\n      <Timer />\n      <Show />\n      <SPDisplay />\n    </AppWrapper>\n  );\n};\n\nconst AppWrapper = styled.div`\n  position: relative;\n  text-align: center;\n  height: 100%;\n  width: 100%;\n`;\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./modules/Reducers\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}