{"version":3,"sources":["components/Header.js","components/Select.js","modules/Maze.js","modules/MazeAnswer.js","modules/Reducers.js","containers/SelectContainer.js","components/Timer.js","containers/TimerContainer.js","components/Show.js","containers/ShowContainer.js","components/App.js","reportWebVitals.js","index.js"],"names":["Header","React","Component","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","ModalWindow","className","onClick","props","openModalWindow","isOpen","this","isModalOpen","onRequestClose","closeModalWindow","style","contentLabel","overlayClassName","onChange","event","handleSizeChange","target","value","size","handleModeChange","mode","timer","handleSetMaze","handleShowAnswer","DIRECTIONS","Maze","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","getKeyArray","key","digGoal","mazeAnswerData","getAnswerRoute","setTimerState","state","goal","start","toText","time","initialState","data","answerData","answerShow","DEFAULTSIZE","movable","minutes","seconds","milliSeconds","intervalID","currentState","createSlice","name","reducers","sizeChange","action","payload","modeChange","setMaze","newMazeData","newAnswerData","clearInterval","openWindow","closeWindow","movePoint","switchMovable","nextX","nextY","isAvailable","showAnswer","startTimer","stopTimer","updateTimer","parseInt","store","configureStore","reducer","connect","dispatch","actions","update","setInterval","getState","close","resume","Timer","componentDidMount","document","addEventListener","handleUseTimer","componentWillUnmount","removeEventListener","onKeyDown","id","stop","Show","keyDownAction","rowIndex","colIndex","goalPoint","answerIndex","sideLength","roadStyle","padding","width","height","lineheight","border","display","boxsizing","rowStyle","map","row","point","road","type","backgroundColor","getPayload","App","SelectContainer","TimerContainer","ShowContainer","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"6NAQeA,E,4JALb,WACE,OAAO,wE,GAFUC,IAAMC,W,iBCCrBC,EAAc,CAClBC,QAAS,CACPC,IAAK,MACLC,KAAM,MACNC,MAAO,OACPC,OAAQ,OACRC,YAAa,OACbC,UAAW,0BAIfC,IAAMC,cAAc,S,IACCC,E,4JACnB,WAAU,IAAD,OAqBP,OACE,sBAAKC,UAAU,OAAf,UACE,wBAAQC,QAAS,kBAAM,EAAKC,MAAMC,mBAAlC,sCACA,eAAC,IAAD,CACEC,OAAQC,KAAKH,MAAMI,YACnBC,eAAgB,kBAAM,EAAKL,MAAMM,oBACjCC,MAAOpB,EACPqB,aAAa,UACbC,iBAAiB,UALnB,UAOE,4EACA,+IACA,qBAAIX,UAAU,OAAd,UACE,iEACS,IACP,yBACEA,UAAU,aACVY,SAAU,SAACC,GAAD,OACR,EAAKX,MAAMY,iBAAiBD,EAAME,OAAOC,QAH7C,UAME,yBAAQA,MAAM,GAAd,UACGX,KAAKH,MAAMe,KADd,SACuBZ,KAAKH,MAAMe,QAElC,wBAAQD,MAAM,KAAd,wBACA,wBAAQA,MAAM,KAAd,wBACA,wBAAQA,MAAM,KAAd,wBACA,wBAAQA,MAAM,KAAd,wBACA,wBAAQA,MAAM,KAAd,8BAGJ,iEACS,IACP,yBACEhB,UAAU,aACVY,SAAU,SAACC,GAAD,OACR,EAAKX,MAAMgB,iBAAiBL,EAAME,OAAOC,QAH7C,UAME,yBAAQA,MAAM,GAAd,UACuB,IAApBX,KAAKH,MAAMiB,KAAa,eAAO,eADlC,wBAGA,wBAAQH,MAAM,IAAd,4CACA,wBAAQA,MAAM,IAAd,qDAIN,wFACYX,KAAKH,MAAMe,KADvB,SACgCZ,KAAKH,MAAMe,QAE3C,+BAAyB,IAApBZ,KAAKH,MAAMiB,KAAa,eAAO,eAApC,qCACA,uBAtEqB,SAArB,EAAKjB,MAAMkB,MAEX,gCACE,wBAAQnB,QAAS,kBAAM,EAAKC,MAAMmB,iBAAlC,wDAGA,wBAAQpB,QAAS,kBAAM,EAAKC,MAAMoB,oBAAlC,0BACA,wBAAQrB,QAAS,kBAAM,EAAKC,MAAMM,oBAAlC,mCAOJ,wBAAQP,QAAS,kBAAM,EAAKC,MAAMmB,iBAAlC,kE,GAjBiClC,IAAMC,W,OCRzCmC,EAAa,CACjB,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,EAAE,EAAG,IAGcC,E,WACnB,WAAYP,GAAO,oBACjBZ,KAAKoB,MAAQR,EACbZ,KAAKqB,MAAQT,E,8CAGf,WAEE,IADA,IAAMU,EAAO,IAAIC,MAAMvB,KAAKoB,OACnBI,EAAS,EAAGA,EAASxB,KAAKoB,MAAOI,IAAU,CAClDF,EAAKE,GAAU,IAAID,MAAMvB,KAAKqB,OAC9B,IAAK,IAAII,EAAS,EAAGA,EAASzB,KAAKqB,MAAOI,IACxCH,EAAKE,GAAQC,IAAU,EAI3B,OADAH,EAAKtB,KAAKoB,MAAQ,GAAG,IAAK,EACnBE,I,uBAGT,SAAUE,EAAQC,GAEhB,IADA,IAAMC,EAAY,CAAC,EAAG1B,KAAKqB,MAAQ,EAAGrB,KAAKoB,MAAQ,EAAG,GAC7CO,EAAY,EAAGA,EAlCV,EAkCiCA,IAC7C,GACGA,EAAY,IAAM,GAAKH,IAAWE,EAAUC,IAC5CA,EAAY,IAAM,GAAKF,IAAWC,EAAUC,GAE7C,OAAO,EAGX,OAAO,I,6BAGT,SAAgBH,EAAQC,EAAQE,EAAWL,GACzC,IAAMM,EAAaJ,EAASN,EAAWS,GA5CjC,GA6CAE,EAAaJ,EAASP,EAAWS,GA5CjC,GA6CN,SACmC,IAAjCL,EAAKM,GAAYC,KACjB7B,KAAK8B,UAAUF,EAAYC,M,kCAa/B,SAAqBL,EAAQC,EAAQH,GAEnC,IADA,IAAMS,EAAoB,GACjBJ,EAAY,EAAGA,EAjEV,EAiEiCA,IAAa,CAE1D,IADA,IAAIK,EAAa,EAEXC,EAA0B,EAC9BA,EArEU,EAsEVA,IACA,CACA,IAAIC,GAAoBD,EAA0B,GAAK,EACvD,GAAIjC,KAAKmC,gBAAgBX,EAAQC,EAAQE,EAAWL,GAAO,CACzD,IAAIM,EACFJ,EAASN,EAAWS,GAzEtB,GAyEsCT,EAAWgB,GAzEjD,GA0EIL,EACFJ,EAASP,EAAWS,GA1EtB,GA0EsCT,EAAWgB,GA1EjD,GA2EKZ,EAAKM,GAAYC,IACpBG,KAIa,IAAfA,GACFD,EAAkBK,KAAKT,GAG3B,OAAOI,I,uBAGT,SAAUP,EAAQC,EAAQH,GACxB,SACEA,EAAKE,GAAQC,IAC8C,IAA3DzB,KAAKqC,qBAAqBb,EAAQC,EAAQH,GAAMgB,U,6BAOpD,SAAgBhB,GACd,IAAK,IAAIE,EAAS,EAAGA,EAASxB,KAAKoB,MAAQ,EAAGI,IAC5C,IAAK,IAAIC,EAAS,EAAGA,EAASzB,KAAKqB,MAAQ,EAAGI,IAC5C,GAAIzB,KAAKuC,UAAUf,EAAQC,EAAQH,GACjC,OAAO,EAIb,OAAO,I,qBAGT,SAAQE,EAAQC,EAAQe,EAAkBlB,GACxC,IAAMmB,EAAY,GAIlB,OAHAA,EA/GM,GA+GSjB,EAASN,EAAWsB,GA/G7B,GAgHNC,EA/GM,GA+GShB,EAASP,EAAWsB,GA/G7B,GAgHNlB,EAAKmB,EAjHC,IAiHaA,EAhHb,KAgH6B,EAC5BA,I,qBAGT,SAAQnB,GAGN,IAFA,IAAIE,EAASxB,KAAKoB,MAAQ,EACtBK,EAAS,EACNzB,KAAK0C,gBAAgBpB,IAAO,CACjC,IAAMqB,EAAa3C,KAAKqC,qBAAqBb,EAAQC,EAAQH,GAC7D,GAAIqB,EAAWL,OAAS,EAAG,CACzB,IAAME,EAAmBI,KAAKC,MAAMD,KAAKE,SAAWH,EAAWL,QACzDG,EAAYzC,KAAK+C,QACrBvB,EACAC,EACAkB,EAAWH,GACXlB,GAEEmB,EAAUH,OAAS,IACrBd,EAASiB,EAnIT,GAoIAhB,EAASgB,EAnIT,SAqIG,GAA0B,IAAtBE,EAAWL,OAAc,CAClC,IAAMU,EAAmBhD,KAAKiD,gBAAgB3B,GACrB,IAArB0B,IACFxB,EAASwB,EAzIT,GA0IAvB,EAASuB,EAzIT,KA6IN,OAAO1B,I,6BAGT,SAAgBA,GAEd,IADA,IAAM0B,EAAmB,GAChBxB,EAAS,EAAGA,EAASxB,KAAKoB,MAAQ,EAAGI,IAC5C,IAAK,IAAIC,EAAS,EAAGA,EAASzB,KAAKqB,MAAQ,EAAGI,IAC5C,GAAIH,EAAKE,GAAQC,IACXzB,KAAKqC,qBAAqBb,EAAQC,EAAQH,GAAMgB,OAAS,EAAG,CAC9D,IAAIY,EAAwB,CAAC1B,EAAQC,GACrCuB,EAAiBZ,KAAKc,GACtB,MAKR,OAAIF,EAAiBV,OAAS,EAIrBU,EAHmBJ,KAAKC,MAC7BD,KAAKE,SAAWE,EAAiBV,SAI9B,I,qBAGT,SAAQxB,GAIN,IAHA,IAAMqC,EAAO,CAAC,EAAGnD,KAAKqB,MAAQ,GAC1BC,EAAOtB,KAAKoD,aACZC,EAASrD,KAAKsD,QAAQhC,IAClBA,EAAK6B,EA3KP,IA2KgBA,EA1KhB,KA2KJ7B,EAAOtB,KAAKoD,aACZC,EAASrD,KAAKsD,QAAQhC,GAMxB,OAJA+B,EAAOrD,KAAKoB,MAAQ,GAAG,IAAK,EA5Kd,IA6KVmC,OAAOzC,KACTuC,EAAO,GAAGrD,KAAKqB,MAAQ,IAAK,GAEvBgC,M,KC7KLnC,EAAa,CACjB,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,EAAE,EAAG,IAGcsC,E,WACnB,WAAYlC,GAAO,oBACjBtB,KAAKyD,SAAWnC,EAAKgB,OACrBtC,KAAK0D,SAAWpC,E,qDAGlB,SAAkBA,EAAMqC,GACtB,IAAK,IAAIhC,EAAY,EAAGA,EAtBV,EAsBiCA,IAAa,CAC1D,IAAMc,EAAY,CAChBkB,EAtBE,GAsBczC,EAAWS,GAtBzB,GAuBFgC,EAtBE,GAsBczC,EAAWS,GAtBzB,IAwBJ,GAAIL,EAAKmB,EAzBL,IAyBmBA,EAxBnB,IAyBF,OAAOA,EAGX,OAAO,I,sBAGT,SAASnB,GACP,IAAK,IAAIE,EAAS,EAAGA,EAASxB,KAAKyD,SAAUjC,IAC3C,IAAK,IAAIC,EAAS,EAAGA,EAASzB,KAAKyD,SAAUhC,IAC3C,GAAIH,EAAKE,GAAQC,GACf,OAAO,EAIb,OAAO,I,4BAGT,SAAeH,EAAMsC,GACnB,IAAoB,IAAhBA,EACF,OAAO,EAGT,IADA,IAAIC,EAAiB,EACZlC,EAAY,EAAGA,EAlDV,EAkDiCA,IAAa,CAC1D,IAAMc,EAAY,CAChBmB,EAlDE,GAkDe1C,EAAWS,GAlD1B,GAmDFiC,EAlDE,GAkDe1C,EAAWS,GAlD1B,IAoDAL,EAAKmB,EArDL,IAqDmBA,EApDnB,KAqDFoB,IAGJ,OAAOA,EAAiB,GAAID,I,kCAG9B,SAAqBE,EAAQH,GAE3B,IADA,IAAII,EAAoBD,EAAO,GAEzBE,EAAgB,EACpBA,EAAgBF,EAAOxB,OACvB0B,IAEA,IACE,IAAIC,EAAa,EACjBA,EAAaH,EAAOE,GAAe1B,OACnC2B,IAEIH,EAAOE,GAAeC,KAAgBN,IACxCI,EAAoBD,EAAOE,IAIjC,OAAOD,I,8BAGT,SAAiBJ,EAAYG,GAC3B,GAAsB,IAAlBA,EAAOxB,OACT,MAAO,CAACqB,GAGV,IADA,IAAMI,EAAoB/D,KAAKkE,qBAAqBJ,EAAQH,GAEtDM,EAAaF,EAAkBzB,OAAS,EAC5C2B,GAAc,EACdA,IAEA,GAAIF,EAAkBE,KAAgBN,EACpC,OAAOI,EAAkBI,MAAM,EAAGF,EAAa,GAGnD,MAAO,CAACN,K,2BAGV,SAAcrC,EAAM8C,GAClB,IACE,IAAIC,EAAmBD,EAAa9B,OAAS,EAC7C+B,GAAoB,EACpBA,IAEA,IACmE,IAAjErE,KAAKsE,kBAAkBhD,EAAM8C,EAAaC,IAE1C,OAAOD,EAAaC,K,uBAK1B,SAAU/C,EAAMqC,EAAYG,EAAQM,GAElC,IADA,IAAMG,EAAiBvE,KAAKwE,iBAAiBb,EAAYG,GAClD9D,KAAKyE,SAASnD,IAAO,CAC1B,IAAMmB,EAAYzC,KAAKsE,kBAAkBhD,EAAMqC,GACzCe,EAAc1E,KAAK2E,eAAerD,EAAMqC,GAK9C,IAJoB,IAAhBe,GACFN,EAAahC,KAAKsC,GAEpBpD,EAAKqC,EAvHD,IAuHgBA,EAtHhB,KAsHiC,GACnB,IAAdlB,EAKF,OAJ8B,IAA1B8B,EAAejC,QACjBwB,EAAO1B,KAAKmC,GAEdZ,EAAa3D,KAAK4E,cAActD,EAAM8C,GAC/BpE,KAAK6E,UAAUvD,EAAMqC,EAAYG,EAAQM,GAElDG,EAAenC,KAAKK,GACpBkB,EAAalB,EAEf,OAAOqB,I,4BAGT,SAAehD,GACb,IAAMgE,EAAWC,KAAKC,MAAMD,KAAKE,UAAUjF,KAAK0D,WAChDoB,EAAS9E,KAAKyD,SAAW,GAAG,IAAK,EACjCqB,EAAS,GAAG9E,KAAKyD,SAAW,IAAK,EACjC,IAAMyB,EAAiB,CAAClF,KAAKyD,SAAW,EAAG,GACrC0B,EAAiB,CAAC,EAAGnF,KAAKyD,SAAW,GAGrC2B,EAAYpF,KAAK6E,UACrBC,EACAI,EAJa,GACM,IAQrB,GAjJc,IAiJV3B,OAAOzC,GACT,IAAK,IAAIuE,EAAU,EAAGA,EAAUD,EAAU9C,OAAQ+C,IAChD,IACE,IAAIpB,EAAa,EACjBA,EAAamB,EAAUC,GAAS/C,OAChC2B,IAEA,GACEmB,EAAUC,GAASpB,GA5JrB,KA4JwCkB,EA5JxC,GA4J4D,GAC1DC,EAAUC,GAASpB,GA5JrB,KA4JwCkB,EA5JxC,GA6JE,CACA,IAAMG,EAAmBF,EAAUC,GAASlB,MAC1C,EACAF,EAAa,GAGf,OADAqB,EAAiBlD,KAAK+C,GACfG,EAMf,GAtKgB,IAsKZ/B,OAAOzC,GAAuB,CAEhC,IADA,IAAIyE,EAAqBH,EAAU,GAC1BC,EAAU,EAAGA,EAAUD,EAAU9C,OAAQ+C,IAC5CE,EAAmBjD,OAAS8C,EAAUC,GAAS/C,SACjDiD,EAAqBH,EAAUC,IAGnC,OAAOE,O,aC1KAC,EAAc,SAACC,GAC1B,OAAQA,GACN,IAAK,UACH,MAAO,EAAE,EAAG,GACd,IAAK,aACH,MAAO,CAAC,EAAG,GACb,IAAK,YACH,MAAO,CAAC,EAAG,GACb,IAAK,YACH,MAAO,CAAC,GAAI,GACd,QACE,MAAO,CAAC,EAAG,KAQX/B,EADO,IAAIvC,EArBU,IAsBLuE,QArBK,GAuBrBC,EADa,IAAInC,EAAWE,GACAkC,eAvBP,GA4DrBC,EAAgB,SAACC,GACrB,OAAIA,EAAMC,KA5CK,KA4COD,EAAMtE,QAAUsE,EAAMC,KA3C7B,KA2CyCD,EAAMrE,OACrD,SAEFqE,EAAMtE,SAAWsE,EAAME,MA/Cf,IA+C2BF,EAAMrE,SAAWqE,EAAME,MA9ClD,GA+CX,OACA,SAGAC,EAAS,SAACC,GACd,OAAQ,MAAQA,GAAM/B,OAAO,IAGzBgC,EAAe,CACnBvF,KA3EyB,GA4EzBE,KA3EyB,EA4EzBsF,KAAM1C,EACN2C,WAAYV,EACZW,YAAY,EACZrG,aAAa,EACb+F,MAAO,CAACO,EAAiB,GACzBR,KAAM,CAAC,EAAGQ,GACVC,SAAS,EACThF,OAAQ+E,EACR9E,OAAQ,EACRgF,QAAS,MACTC,QAAS,MACTC,aAAc,MACdT,KAAM,EACNnF,MAAO,OACP6F,YAAa,GAGFC,EAAeC,YAAY,CACtCC,KAAM,YACNZ,eACAa,SAAU,CACRC,WAAY,SAACnB,EAAOoB,GAClB,OAAO,2BACFpB,GADL,IAEElF,KAAMsG,EAAOC,WAGjBC,WAAY,SAACtB,EAAOoB,GAClB,OAAO,2BACFpB,GADL,IAEEhF,KAAMoG,EAAOC,WAGjBE,QAAS,SAACvB,GACR,IAvEWlF,EAAME,EAAMuF,EAwEjBiB,EADU,IAAInG,EAAK2E,EAAMlF,MACH8E,QAAQI,EAAMhF,MAEpCyG,EADY,IAAI/D,EAAW8D,GACD1B,eAAeE,EAAMhF,MAErD,OADA0G,cAAc1B,EAAMc,YACb,2BACFd,GADL,IAEEM,KAAMkB,EACNjB,WAAYkB,EACZtH,aAAa,EACbqG,YAAY,EACZ9E,OAAQsE,EAAMlF,KAAO,EACrBa,OAAQ,EACRuE,MAAO,CAACF,EAAMlF,KAAO,EAAG,GACxBmF,MArFSnF,EAqFKkF,EAAMlF,KArFLE,EAqFWgF,EAAMhF,KArFXuF,EAqFiBkB,EA/H1B,IA2CdzG,EACsB,CACtBuF,EAAWlC,OAAO,GAAG,GAzBV,GA0BXkC,EAAWlC,OAAO,GAAG,GAzBV,IA6BR,CAAC,EAAGvD,EAAO,IA8EZ6F,QAAS,MACTC,QAAS,MACTC,aAAc,MACdT,KAAM,EACNnF,MAAO,OACP6F,YAAa,KAGjBa,WAAY,SAAC3B,EAAOoB,GAElB,OADAM,cAAc1B,EAAMc,YACb,2BACFd,GADL,IAEE7F,YAAaiH,EAAOC,QACpBpG,MAAO,WAGX2G,YAAa,SAAC5B,EAAOoB,GACnB,OAAO,2BACFpB,GADL,IAEE7F,YAAaiH,EAAOC,QACpBpG,MAAO8E,EAAcC,MAGzB6B,UAAW,SAAC7B,EAAOoB,GACjB,IAAMV,EAnGU,SAACV,GACrB,OACGA,EAAMtE,SAAWsE,EAAMC,KAnCX,IAmCsBD,EAAMrE,SAAWqE,EAAMC,KAlC7C,MAmCS,IAAtBD,EAAM7F,YAgGY2H,CAAc9B,GAC9B,IAAKU,EACH,OAAO,eACFV,GAGP,IAAMrD,EAlIQ,SAACqD,EAAOqB,GAC1B,GAAIrB,EAAMtE,SAAWsE,EAAMlF,KAAO,GAAqB,YAAhBuG,EAAQ1B,IAC7C,MAAO,CAACK,EAAMtE,OAAQsE,EAAMrE,QAE9B,IAAMgB,EAAY,CAChBqD,EAAMtE,OAAS2F,EAAQU,MACvB/B,EAAMrE,OAAS0F,EAAQW,OAEzB,OAAKhC,EAAMM,KAAK3D,EAhBD,IAgBeA,EAff,IAkBRA,EAFE,CAACqD,EAAMtE,OAAQsE,EAAMrE,QAyHRsG,CAAYjC,EAAOoB,EAAOC,SAC5C,OAAO,2BACFrB,GADL,IAEEtE,OAAQiB,EA7IC,GA8IThB,OAAQgB,EA7IC,GA8IT+D,QAASA,KAGbwB,WAAY,SAAClC,EAAOoB,GAClB,OAAO,2BACFpB,GADL,IAEEQ,WAAYY,EAAOC,QACnBlH,aAAa,KAGjBgI,WAAY,SAACnC,EAAOoB,GAClB,OAAO,2BACFpB,GADL,IAEEc,WAAYM,EAAOC,QACnBpG,MAAO,WAGXmH,UAAW,SAACpC,GAEV,OADA0B,cAAc1B,EAAMc,YACb,2BACFd,GADL,IAEEc,YAAa,KAGjBuB,YAAa,SAACrC,GACZ,IAAMI,EAAOJ,EAAMI,KAAO,EACpBO,EAAU2B,SAAUlC,EAAO,IAAM,GAAM,IAAK,IAC5CQ,EAAU0B,SAAUlC,EAAO,IAAO,GAAI,IACtCS,EAAeyB,SAASlC,EAAO,IAAK,IAC1C,OAAO,2BACFJ,GADL,IAEEW,QAASR,EAAOQ,GAChBC,QAAST,EAAOS,GAChBC,aAAcV,EAAOU,GACrBT,KAAMA,QAMDmC,EAAQC,YAAe,CAClCC,QAAS1B,EAAa0B,U,OC7JTC,eA/CS,SAAC1C,GACvB,OAAOA,KAGkB,SAAC2C,GAC1B,MAAO,CACLhI,iBAAkB,SAACG,GACjB,IAAMqG,EAAaJ,EAAa6B,QAAQzB,WAAW1D,OAAO3C,IAC1D6H,EAASxB,IAEXpG,iBAAkB,SAACC,GACjB,IAAMsG,EAAaP,EAAa6B,QAAQtB,WAAW7D,OAAOzC,IAC1D2H,EAASrB,IAEXpG,cAAe,WACb,IAAMqG,EAAUR,EAAa6B,QAAQrB,UACrCoB,EAASpB,GAET,IAAMsB,EAAS9B,EAAa6B,QAAQP,cAC9BvB,EAAagC,aAAY,kBAAMH,EAASE,KAAS,IACjD3C,EAAQa,EAAa6B,QAAQT,WAAWrB,GAC9C6B,EAASzC,IAEXlG,gBAAiB,WACf,IAAM2H,EAAaZ,EAAa6B,QAAQjB,YAAW,GACnDgB,EAAShB,IAEXtH,iBAAkB,WAAO,IACfY,EAAUsH,EAAMQ,WAAhB9H,MACF+H,EAAkB,SAAV/H,EACR2G,EAAcb,EAAa6B,QAAQhB,YAAYoB,GAGrD,GAFAL,EAASf,GAEK,UAAV3G,GAA+B,UAAVA,EAAmB,CAC1C,IAAM4H,EAAS9B,EAAa6B,QAAQP,cAC9BvB,EAAagC,aAAY,kBAAMH,EAASE,KAAS,IACjDI,EAASlC,EAAa6B,QAAQT,WAAWrB,GAC/C6B,EAASM,KAGb9H,iBAAkB,WAChB,IAAM+G,EAAanB,EAAa6B,QAAQV,YAAW,GACnDS,EAAST,OAKAQ,CAA6C9I,GCtB7CsJ,E,4MA1BbC,kBAAoB,WAClBC,SAASC,iBAAiB,WAAW,SAAC3I,GAAD,OACnC,EAAKX,MAAMuJ,eAAe5I,EAAMiF,S,EAGpC4D,qBAAuB,WACrBH,SAASI,oBAAoB,WAAW,SAAC9I,GAAD,OACtC,EAAKX,MAAMuJ,eAAe5I,EAAMiF,S,4CAIpC,WAAU,IAAD,OACP,OACE,sBAAK9F,UAAU,QAAQ4J,UAAW,kBAAM,EAAK1J,MAAMuJ,kBAAnD,UACE,iEACA,qBAAKI,GAAG,YAAR,SACE,+BACGxJ,KAAKH,MAAM4G,QADd,MAC0BzG,KAAKH,MAAM6G,QADrC,KACgD,IAC7C1G,KAAKH,MAAM8G,yB,GAnBJ7H,IAAMC,WCoBXyJ,eAlBS,SAAC1C,GACvB,OAAOA,KAGkB,SAAC2C,GAC1B,MAAO,CACLW,eAAgB,SAAC3D,GAAS,IAAD,EACU4C,EAAMQ,WAA/BrH,EADe,EACfA,OAAQC,EADO,EACPA,OAAQsE,EADD,EACCA,KAClB8B,EAAQrG,EAASgE,EAAYC,GHYxB,GGXLqC,EAAQrG,EAAS+D,EAAYC,GHYxB,GGXX,GAAIM,EHUO,KGVK8B,GAAS9B,EHWd,KGX0B+B,EAAO,CAC1C,IAAM2B,EAAO5C,EAAa6B,QAAQR,YAClCO,EAASgB,QAMFjB,CAA6CQ,GC6F7CU,E,4MA7GbT,kBAAoB,WAClBC,SAASC,iBAAiB,WAAW,SAAC3I,GAAD,OACnC,EAAKX,MAAM8J,cAAcnJ,EAAMiF,S,EAGnC4D,qBAAuB,WACrBH,SAASI,oBAAoB,WAAW,SAAC9I,GAAD,OACtC,EAAKX,MAAM8J,cAAcnJ,EAAMiF,S,4CAInC,WAAU,IAAD,SAC4BzF,KAAKH,MAAhCuG,EADD,EACCA,KAAMC,EADP,EACOA,WAAYzF,EADnB,EACmBA,KACpB+G,EAAY,SAACiC,EAAUC,GAC3B,OAAID,IAAa,EAAK/J,MAAM2B,QAAUqI,IAAa,EAAKhK,MAAM4B,QAa1DuG,EAAa,SAAC4B,EAAUC,EAAUvD,GACtC,IAAmB,IAAfA,EACF,QATc,SAACsD,EAAUC,GAC3B,OAAID,IAAa,EAAK/J,MAAMkG,KAzBxB,IAyBmC8D,IAAa,EAAKhK,MAAMkG,KAxB3D,GAgCK+D,CAAUF,EAAUC,GAE7B,IACE,IAAIE,EAAc,EAClBA,EAAc1D,EAAW/D,OACzByH,IAEA,GACE1D,EAAW0D,GAzCX,KAyC+BH,GAC/BvD,EAAW0D,GAzCX,KAyC+BF,EAE/B,OAAO,EAGX,OAAO,GAGHG,EAAa,IAAMpJ,EACnBqJ,EAAY,CAChBC,QAAS,EACTC,MAAOH,EACPI,OAAQJ,EACRK,WAAYL,EACZM,OAAQ,OACRC,QAAS,eACTC,UAAW,cAGPC,EAAW,CACfP,QAAS,EACTE,OAAQ,IAAMxJ,GAGhB,OAEE,aADA,CACA,OAAKjB,UAAU,OAAO4J,UAAW,kBAAM,EAAK1J,MAAM8J,iBAAlD,SACE,qBAAKhK,UAAU,eAAf,SACGyG,EAAKsE,KAAI,SAACC,EAAKf,GACd,OACE,qBAAKxJ,MAAOqK,EAAZ,SACGE,EAAID,KAAI,SAACE,EAAOf,GACf,IAAMgB,EAAOD,EACb,OACE,uBACEE,KAAK,SAELnL,UACEgI,EAAUiC,EAAUC,GAApB,uBAEaD,GAFb,OAEwBC,GAE1BzJ,MAAK,2BACA6J,GADA,IAEHc,gBAAiBF,EACb7C,EACE4B,EACAC,EACA,EAAKhK,MAAMyG,YAEX,UACA,GACF,WAlBR,cAEcsD,EAFd,gBAE8BC,QANpC,cAAkCD,e,GArE7B9K,IAAMC,WCsBVyJ,eAvBS,SAAC1C,GACvB,OAAOA,KAYkB,SAAC2C,GAC1B,MAAO,CACLkB,cAAe,SAAClE,GACd,IAAM0B,EAZO,SAAC1B,GAClB,IAAMhD,EAAY+C,EAAYC,GAC9B,MAAO,CACLoC,MAAOpF,ELaM,GKZbqF,MAAOrF,ELaM,GKZbgD,IAAKA,GAOauF,CAAWvF,GACrBkC,EAAYd,EAAa6B,QAAQf,UAAUR,GACjDsB,EAASd,OAKAa,CAA6CkB,GCP7CuB,G,kKAZb,WACE,OACE,sBAAKtL,UAAU,MAAf,UACE,cAAC,EAAD,IACA,cAACuL,EAAD,IACA,cAACC,EAAD,IACA,cAACC,EAAD,W,GAPUtM,IAAMC,YCKTsM,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCCdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,IAAD,CAAU3D,MAAOA,EAAjB,SACE,cAAC,EAAD,QAGJa,SAAS+C,eAAe,SAM1BZ,M","file":"static/js/main.91206ec6.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Header extends React.Component {\n  render() {\n    return <header>迷路ゲーム</header>;\n  }\n}\n\nexport default Header;\n","import React from \"react\";\nimport Modal from \"react-modal\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nexport default class ModalWindow extends React.Component {\n  render() {\n    const buttons = () => {\n      if (this.props.timer !== \"stop\") {\n        return (\n          <div>\n            <button onClick={() => this.props.handleSetMaze()}>\n              生成＆スタート\n            </button>\n            <button onClick={() => this.props.handleShowAnswer()}>解答</button>\n            <button onClick={() => this.props.closeModalWindow()}>\n              閉じる\n            </button>\n          </div>\n        );\n      }\n      return (\n        <button onClick={() => this.props.handleSetMaze()}>\n          生成＆スタート\n        </button>\n      );\n    };\n    return (\n      <div className=\"menu\">\n        <button onClick={() => this.props.openModalWindow()}>メニュー</button>\n        <Modal\n          isOpen={this.props.isModalOpen}\n          onRequestClose={() => this.props.closeModalWindow()}\n          style={windowStyle}\n          contentLabel=\"EXAMPLE\"\n          overlayClassName=\"overlay\"\n        >\n          <h3>迷路オプション</h3>\n          <p> 迷路サイズ・モードを選択してください </p>\n          <ul className=\"list\">\n            <li>\n              迷路サイズ:{\" \"}\n              <select\n                className=\"selectSize\"\n                onChange={(event) =>\n                  this.props.handleSizeChange(event.target.value)\n                }\n              >\n                <option value=\"\">\n                  {this.props.size} × {this.props.size}\n                </option>\n                <option value=\"10\">10 × 10</option>\n                <option value=\"20\">20 × 20</option>\n                <option value=\"30\">30 × 30</option>\n                <option value=\"40\">40 × 40</option>\n                <option value=\"50\">50 × 50</option>\n              </select>\n            </li>\n            <li>\n              モード選択:{\" \"}\n              <select\n                className=\"selectMode\"\n                onChange={(event) =>\n                  this.props.handleModeChange(event.target.value)\n                }\n              >\n                <option value=\"\">\n                  {this.props.mode === 1 ? \"到達\" : \"最長\"}モード\n                </option>\n                <option value=\"1\">到達モード</option>\n                <option value=\"2\">最長モード</option>\n              </select>\n            </li>\n          </ul>\n          <h4>\n            現在の迷路サイズは{this.props.size} × {this.props.size}\n          </h4>\n          <h4>{this.props.mode === 1 ? \"到達\" : \"最長\"} モードです</h4>\n          <br />\n          {buttons()}\n        </Modal>\n      </div>\n    );\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport { createSlice, configureStore } from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nexport const DEFAULTSIZE = 10;\nexport const DEFAULTMODE = 1;\n\nexport const getKeyArray = (key) => {\n  switch (key) {\n    case \"ArrowUp\":\n      return [-1, 0];\n    case \"ArrowRight\":\n      return [0, 1];\n    case \"ArrowDown\":\n      return [1, 0];\n    case \"ArrowLeft\":\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n};\n\nexport const X = 0;\nexport const Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (\n    (state.xIndex === state.goal[X] && state.yIndex === state.goal[Y]) ||\n    state.isModalOpen === true\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst setTimerState = (state) => {\n  if (state.goal[X] === state.xIndex && state.goal[Y] === state.yIndex) {\n    return \"finish\";\n  }\n  return state.xIndex === state.start[X] && state.yIndex === state.start[Y]\n    ? \"stop\"\n    : \"start\";\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: true,\n  start: [DEFAULTSIZE - 1, 1],\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: \"stop\",\n  intervalID: -1,\n};\n\nexport const currentState = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        start: [state.size - 1, 1],\n        goal: setGoal(state.size, state.mode, newAnswerData),\n        minutes: \"000\",\n        seconds: \"000\",\n        milliSeconds: \"000\",\n        time: 0,\n        timer: \"stop\",\n        intervalID: -1,\n      };\n    },\n    openWindow: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: \"pause\",\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state);\n      if (!movable) {\n        return {\n          ...state,\n        };\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n        isModalOpen: false,\n      };\n    },\n    startTimer: (state, action) => {\n      return {\n        ...state,\n        intervalID: action.payload,\n        timer: \"start\",\n      };\n    },\n    stopTimer: (state) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        intervalID: -1,\n      };\n    },\n    updateTimer: (state) => {\n      const time = state.time + 1;\n      const minutes = parseInt((time / 100 / 60) % 100, 10);\n      const seconds = parseInt((time / 100) % 60, 10);\n      const milliSeconds = parseInt(time % 100, 10);\n      return {\n        ...state,\n        minutes: toText(minutes),\n        seconds: toText(seconds),\n        milliSeconds: toText(milliSeconds),\n        time: time,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  reducer: currentState.reducer,\n});\n","import ModalWindow from \"../components/Select\";\nimport { currentState, store } from \"../modules/Reducers\";\nimport { connect } from \"react-redux\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleSizeChange: (size) => {\n      const sizeChange = currentState.actions.sizeChange(Number(size));\n      dispatch(sizeChange);\n    },\n    handleModeChange: (mode) => {\n      const modeChange = currentState.actions.modeChange(Number(mode));\n      dispatch(modeChange);\n    },\n    handleSetMaze: () => {\n      const setMaze = currentState.actions.setMaze();\n      dispatch(setMaze);\n\n      const update = currentState.actions.updateTimer();\n      const intervalID = setInterval(() => dispatch(update), 10);\n      const start = currentState.actions.startTimer(intervalID);\n      dispatch(start);\n    },\n    openModalWindow: () => {\n      const openWindow = currentState.actions.openWindow(true);\n      dispatch(openWindow);\n    },\n    closeModalWindow: () => {\n      const { timer } = store.getState();\n      const close = timer === \"stop\" ? true : false;\n      const closeWindow = currentState.actions.closeWindow(close);\n      dispatch(closeWindow);\n\n      if (timer === \"start\" || timer === \"pause\") {\n        const update = currentState.actions.updateTimer();\n        const intervalID = setInterval(() => dispatch(update), 10);\n        const resume = currentState.actions.startTimer(intervalID);\n        dispatch(resume);\n      }\n    },\n    handleShowAnswer: () => {\n      const showAnswer = currentState.actions.showAnswer(true);\n      dispatch(showAnswer);\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ModalWindow);\n","import React from \"react\";\n\nclass Timer extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.handleUseTimer(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.handleUseTimer(event.key)\n    );\n  };\n\n  render() {\n    return (\n      <div className=\"timer\" onKeyDown={() => this.props.handleUseTimer()}>\n        <h5>〈〈 Timer 〉〉</h5>\n        <div id=\"showTimer\">\n          <h5>\n            {this.props.minutes} : {this.props.seconds} :{\" \"}\n            {this.props.milliSeconds}\n          </h5>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Timer;\n","import Timer from \"../components/Timer\";\nimport { connect } from \"react-redux\";\nimport { currentState, store, getKeyArray, X, Y } from \"../modules/Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleUseTimer: (key) => {\n      const { xIndex, yIndex, goal } = store.getState();\n      const nextX = xIndex + getKeyArray(key)[X];\n      const nextY = yIndex + getKeyArray(key)[Y];\n      if (goal[X] === nextX && goal[Y] === nextY) {\n        const stop = currentState.actions.stopTimer();\n        dispatch(stop);\n      }\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Timer);\n","import React from \"react\";\n\nconst X = 0;\nconst Y = 1;\n\nclass Show extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n\n  render() {\n    const { data, answerData, size } = this.props;\n    const movePoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.xIndex && colIndex === this.props.yIndex) {\n        return true;\n      }\n      return false;\n    };\n\n    const goalPoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.goal[X] && colIndex === this.props.goal[Y]) {\n        return true;\n      }\n      return false;\n    };\n\n    const showAnswer = (rowIndex, colIndex, answerShow) => {\n      if (answerShow === false) {\n        return goalPoint(rowIndex, colIndex) ? true : false;\n      }\n      for (\n        let answerIndex = 0;\n        answerIndex < answerData.length;\n        answerIndex++\n      ) {\n        if (\n          answerData[answerIndex][X] === rowIndex &&\n          answerData[answerIndex][Y] === colIndex\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    const sideLength = 500 / size;\n    const roadStyle = {\n      padding: 0,\n      width: sideLength,\n      height: sideLength,\n      lineheight: sideLength,\n      border: \"none\",\n      display: \"inline-block\",\n      boxsizing: \"border-box\",\n    };\n\n    const rowStyle = {\n      padding: 0,\n      height: 500 / size,\n    };\n\n    return (\n      // table要素で書けばいいんじゃね\n      <div className=\"show\" onKeyDown={() => this.props.keyDownAction()}>\n        <div className=\"maze-wrapper\">\n          {data.map((row, rowIndex) => {\n            return (\n              <div style={rowStyle} key={`row:${rowIndex}`}>\n                {row.map((point, colIndex) => {\n                  const road = point;\n                  return (\n                    <input\n                      type=\"button\"\n                      key={`row:${rowIndex},col:${colIndex}`}\n                      className={\n                        movePoint(rowIndex, colIndex)\n                          ? `move`\n                          : `unmove${rowIndex}${colIndex}`\n                      }\n                      style={{\n                        ...roadStyle,\n                        backgroundColor: road\n                          ? showAnswer(\n                              rowIndex,\n                              colIndex,\n                              this.props.answerShow\n                            )\n                            ? \"skyblue\"\n                            : \"\"\n                          : \"black\",\n                      }}\n                    ></input>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        {/* <h4>\n          {this.props.mode === 1 ? \"到達\" : \"最長\"}モード\n          <br />\n          迷路サイズは {this.props.size} × {this.props.size} です\n        </h4> */}\n      </div>\n    );\n  }\n}\n\nexport default Show;\n","import Show from \"../components/Show\";\nimport { connect } from \"react-redux\";\nimport { currentState, getKeyArray, X, Y } from \"../modules/Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst getPayload = (key) => {\n  const nextPoint = getKeyArray(key);\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    key: key,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    keyDownAction: (key) => {\n      const payload = getPayload(key);\n      const movePoint = currentState.actions.movePoint(payload);\n      dispatch(movePoint);\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Show);\n","import React from \"react\";\nimport Header from \"./Header\";\nimport SelectContainer from \"../containers/SelectContainer\";\nimport TimerContainer from \"../containers/TimerContainer\";\nimport ShowContainer from \"../containers/ShowContainer\";\nimport \"../App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <SelectContainer />\n        <TimerContainer />\n        <ShowContainer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./modules/Reducers\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}