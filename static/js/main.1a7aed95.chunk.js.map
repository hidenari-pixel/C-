{"version":3,"sources":["Header.js","ModalWindow.js","Maze.js","MazeAnswer.js","Reducers.js","SelectContainer.js","Timer.js","TimerContainer.js","Show.js","ShowContainer.js","App.js","reportWebVitals.js","index.js"],"names":["Header","React","Component","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","ModalWindow","onClick","props","openModalWindow","isOpen","this","isModalOpen","onRequestClose","closeModalWindow","style","contentLabel","className","onChange","event","handleSizeChange","target","value","handleModeChange","handleSetMaze","DIRECTIONS","Maze","size","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","getKeyArray","key","digGoal","mazeAnswerData","getAnswerRoute","toText","time","initialState","data","answerData","answerShow","start","DEFAULTSIZE","goal","movable","minutes","seconds","milliSeconds","timer","intervalID","currentState","createSlice","name","reducers","sizeChange","state","action","payload","modeChange","setMaze","newMazeData","newAnswerData","clearInterval","openWindow","closeWindow","movePoint","switchMovable","nextX","nextY","isAvailable","showAnswer","startTimer","stopTimer","updateTimer","parseInt","store","configureStore","reducer","connect","dispatch","actions","getState","update","setInterval","resume","Timer","componentDidMount","document","addEventListener","handleUseTimer","componentWillUnmount","removeEventListener","onKeyDown","id","stop","rowStyle","height","roadStyle","width","border","display","boxsizing","lineheight","Show","keyDownAction","rowIndex","colIndex","goalPoint","answerIndex","map","row","point","road","backgroundColor","handleShowAnswer","getPayload","App","SelectContainer","TimerContainer","ShowContainer","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.1a7aed95.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Header extends React.Component {\n  render() {\n    return <header>迷路ゲーム</header>;\n  }\n}\n\nexport default Header;\n","import React from \"react\";\nimport Modal from \"react-modal\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nexport default class ModalWindow extends React.Component {\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.props.openModalWindow()}>メニュー</button>\n        <Modal\n          isOpen={this.props.isModalOpen}\n          onRequestClose={() => this.props.closeModalWindow()}\n          style={windowStyle}\n          contentLabel=\"EXAMPLE\"\n        >\n          <h3>迷路オプション</h3>\n          <ul className=\"list\">\n            <li>\n              迷路サイズ:{\" \"}\n              <select\n                className=\"selectSize\"\n                onChange={(event) =>\n                  this.props.handleSizeChange(event.target.value)\n                }\n              >\n                <option value=\"\">--サイズ選択--</option>\n                <option value=\"10\">10 × 10</option>\n                <option value=\"20\">20 × 20</option>\n                <option value=\"30\">30 × 30</option>\n                <option value=\"40\">40 × 40</option>\n                <option value=\"50\">50 × 50</option>\n              </select>\n            </li>\n            <li>\n              モード選択:{\" \"}\n              <select\n                className=\"selectMode\"\n                onChange={(event) =>\n                  this.props.handleModeChange(event.target.value)\n                }\n              >\n                <option value=\"\">--モードを選択--</option>\n                <option value=\"1\">到達モード ⇨ モード1</option>\n                <option value=\"2\">最長モード　→　モード2</option>\n              </select>\n            </li>\n          </ul>\n          <br />\n          <button onClick={() => this.props.handleSetMaze()}>作成</button>\n          <br />\n          <button onClick={() => this.props.closeModalWindow()}>閉じる</button>\n        </Modal>\n      </div>\n    );\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport { createSlice, configureStore } from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nexport const DEFAULTSIZE = 10;\nexport const DEFAULTMODE = 1;\n\nexport const getKeyArray = (key) => {\n  switch (key) {\n    case \"ArrowUp\":\n      return [-1, 0];\n    case \"ArrowRight\":\n      return [0, 1];\n    case \"ArrowDown\":\n      return [1, 0];\n    case \"ArrowLeft\":\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n};\n\nexport const X = 0;\nexport const Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (\n    (state.xIndex === state.goal[X] && state.yIndex === state.goal[Y]) ||\n    state.isModalOpen === true\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: false,\n  start: [DEFAULTSIZE - 1, 1],\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: false,\n  intervalID: -1,\n};\n\nexport const currentState = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        start: [state.size - 1, 1],\n        goal: setGoal(state.size, state.mode, newAnswerData),\n        minutes: \"000\",\n        seconds: \"000\",\n        milliSeconds: \"000\",\n        intervalID: -1,\n      };\n    },\n    openWindow: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        isModalOpen: action.payload,\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state, action.payload);\n      if (!movable) {\n        return {\n          ...state,\n          timer: false,\n        };\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n        timer: true,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n      };\n    },\n    startTimer: (state, action) => {\n      return {\n        ...state,\n        intervalID: action.payload,\n      };\n    },\n    stopTimer: (state) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        intervalID: -1,\n      };\n    },\n    updateTimer: (state) => {\n      const time = state.time + 1;\n      const minutes = parseInt((time / 100 / 60) % 100, 10);\n      const seconds = parseInt((time / 100) % 60, 10);\n      const milliSeconds = parseInt(time % 100, 10);\n      return {\n        ...state,\n        minutes: toText(minutes),\n        seconds: toText(seconds),\n        milliSeconds: toText(milliSeconds),\n        time: time,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  reducer: currentState.reducer,\n});\n","import ModalWindow from \"./ModalWindow\";\nimport { currentState, store, getKeyArray, X, Y } from \"./Reducers\";\nimport { connect } from \"react-redux\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleSizeChange: (size) => {\n      dispatch(currentState.actions.sizeChange(Number(size)));\n    },\n    handleModeChange: (mode) => {\n      dispatch(currentState.actions.modeChange(Number(mode)));\n    },\n    handleSetMaze: () => {\n      dispatch(currentState.actions.setMaze());\n    },\n    openModalWindow: () => {\n      dispatch(currentState.actions.openWindow(true));\n    },\n    closeModalWindow: () => {\n      dispatch(currentState.actions.closeWindow(false));\n      const { xIndex, yIndex, goal } = store.getState();\n      let timer =\n        xIndex === goal[X] && yIndex === goal[Y]\n          ? false\n          : store.getState().timer;\n      if (timer) {\n        const update = currentState.actions.updateTimer();\n        const intervalID = setInterval(() => dispatch(update), 10);\n        const resume = currentState.actions.startTimer(intervalID);\n        dispatch(resume);\n      }\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ModalWindow);\n","import React from \"react\";\n\nclass Timer extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.handleUseTimer(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.handleUseTimer(event.key)\n    );\n  };\n\n  render() {\n    return (\n      <div className=\"timer\" onKeyDown={() => this.props.handleUseTimer()}>\n        <h5>〈〈 Timer 〉〉</h5>\n        <div id=\"showTimer\">\n          <h5>\n            {this.props.minutes} : {this.props.seconds} :{\" \"}\n            {this.props.milliSeconds}\n          </h5>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Timer;\n","import Timer from \"./Timer\";\nimport { connect } from \"react-redux\";\nimport { currentState, store, getKeyArray, X, Y } from \"./Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleUseTimer: (key) => {\n      const { xIndex, yIndex, goal, timer } = store.getState();\n      const nextX = xIndex + getKeyArray(key)[X];\n      const nextY = yIndex + getKeyArray(key)[Y];\n      if (timer === false) {\n        const update = currentState.actions.updateTimer();\n        const intervalID = setInterval(() => dispatch(update), 10);\n        const start = currentState.actions.startTimer(intervalID);\n        dispatch(start);\n      }\n      if (goal[X] === nextX && goal[Y] === nextY) {\n        const stop = currentState.actions.stopTimer();\n        dispatch(stop);\n      }\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Timer);\n","import React from \"react\";\n\nconst rowStyle = {\n  height: 12,\n};\n\nconst roadStyle = {\n  width: 12,\n  height: 12,\n  border: \"solid 1px gray\",\n  display: \"inline-block\",\n  boxsizing: \"border-box\",\n  lineheight: \"12px\",\n};\n\nconst X = 0;\nconst Y = 1;\n\nclass Show extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n\n  render() {\n    const data = this.props.data;\n    const answerData = this.props.answerData;\n    const movePoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.xIndex && colIndex === this.props.yIndex) {\n        return true;\n      }\n      return false;\n    };\n\n    const goalPoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.goal[X] && colIndex === this.props.goal[Y]) {\n        return true;\n      }\n      return false;\n    };\n\n    const showAnswer = (rowIndex, colIndex, answerShow) => {\n      if (answerShow === false) {\n        return goalPoint(rowIndex, colIndex) ? true : false;\n      }\n      for (\n        let answerIndex = 0;\n        answerIndex < answerData.length;\n        answerIndex++\n      ) {\n        if (\n          answerData[answerIndex][X] === rowIndex &&\n          answerData[answerIndex][Y] === colIndex\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    return (\n      <div className=\"Show\" onKeyDown={() => this.props.keyDownAction()}>\n        <div>\n          {data.map((row, rowIndex) => {\n            return (\n              <div style={rowStyle} key={`row:${rowIndex}`}>\n                {row.map((point, colIndex) => {\n                  const road = point;\n                  return (\n                    <button\n                      key={`row:${rowIndex},col:${colIndex}`}\n                      className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                      style={{\n                        ...roadStyle,\n                        backgroundColor: road\n                          ? showAnswer(\n                              rowIndex,\n                              colIndex,\n                              this.props.answerShow\n                            )\n                            ? \"skyblue\"\n                            : \"\"\n                          : \"black\",\n                      }}\n                    ></button>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <h4>\n          モード {this.props.mode}\n          <br />\n          迷路サイズは {this.props.size} × {this.props.size} です\n        </h4>\n        <button\n          className=\"answerbutton\"\n          onClick={() => this.props.handleShowAnswer()}\n        >\n          迷路の解答\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default Show;\n","import Show from \"./Show\";\nimport { connect } from \"react-redux\";\nimport { currentState, getKeyArray, X, Y } from \"./Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst getPayload = (key) => {\n  const nextPoint = getKeyArray(key);\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    key: key,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    keyDownAction: (key) => {\n      const payload = getPayload(key);\n      dispatch(currentState.actions.movePoint(payload));\n    },\n    handleShowAnswer: () => {\n      dispatch(currentState.actions.showAnswer(true));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Show);\n","import React from \"react\";\nimport Header from \"./Header\";\nimport SelectContainer from \"./SelectContainer\";\nimport TimerContainer from \"./TimerContainer\";\nimport ShowContainer from \"./ShowContainer\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <SelectContainer />\n        <TimerContainer />\n        <ShowContainer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./Reducers\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}