{"version":3,"sources":["Header.js","ModalWindow.js","Maze.js","MazeAnswer.js","Reducers.js","SelectContainer.js","Timer.js","TimerContainer.js","Show.js","ShowContainer.js","App.js","reportWebVitals.js","index.js"],"names":["Header","React","Component","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","ModalWindow","onClick","props","openModalWindow","isOpen","this","isModalOpen","onRequestClose","closeModalWindow","style","contentLabel","className","onChange","event","handleSizeChange","target","value","handleModeChange","handleSetMaze","DIRECTIONS","Maze","size","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","digGoal","mazeAnswerData","getAnswerRoute","toText","time","initialState","data","answerData","answerShow","goal","DEFAULTSIZE","movable","minutes","seconds","milliSeconds","timer","timerState","currentState","createSlice","name","reducers","sizeChange","state","action","payload","modeChange","setMaze","newMazeData","newAnswerData","openWindow","closeWindow","movePoint","switchMovable","Key","nextX","nextY","isAvailable","showAnswer","useTimer","updateTimer","parseInt","key","setStart","setInterval","clearInterval","store","configureStore","reducer","connect","dispatch","actions","Timer","componentDidMount","document","addEventListener","handleTimerUse","componentWillUnmount","removeEventListener","onKeyDown","id","rowStyle","height","roadStyle","width","border","display","boxsizing","lineheight","Show","keyDownAction","rowIndex","colIndex","goalPoint","answerIndex","map","row","point","road","backgroundColor","handleShowAnswer","keyArray","ArrowUp","ArrowRight","ArrowDown","ArrowLeft","Object","keys","includes","getPayload","App","SelectContainer","TimerContainer","ShowContainer","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.0a45a318.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Header extends React.Component {\n  render() {\n    return <header>迷路ゲーム</header>;\n  }\n}\n\nexport default Header;\n","import React from \"react\";\nimport Modal from \"react-modal\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nexport default class ModalWindow extends React.Component {\n  render() {\n    return (\n      <div>\n        <button onClick={() => this.props.openModalWindow()}>メニュー</button>\n        <Modal\n          isOpen={this.props.isModalOpen}\n          onRequestClose={() => this.props.closeModalWindow()}\n          style={windowStyle}\n          contentLabel=\"EXAMPLE\"\n        >\n          <h3>迷路オプション</h3>\n          <ul className=\"list\">\n            <li>\n              迷路サイズ:{\" \"}\n              <select\n                className=\"selectSize\"\n                onChange={(event) =>\n                  this.props.handleSizeChange(event.target.value)\n                }\n              >\n                <option value=\"\">--サイズ選択--</option>\n                <option value=\"10\">10 × 10</option>\n                <option value=\"20\">20 × 20</option>\n                <option value=\"30\">30 × 30</option>\n                <option value=\"40\">40 × 40</option>\n                <option value=\"50\">50 × 50</option>\n              </select>\n            </li>\n            <li>\n              モード選択:{\" \"}\n              <select\n                className=\"selectMode\"\n                onChange={(event) =>\n                  this.props.handleModeChange(event.target.value)\n                }\n              >\n                <option value=\"\">--モードを選択--</option>\n                <option value=\"1\">到達モード ⇨ モード1</option>\n                <option value=\"2\">最長モード　→　モード2</option>\n              </select>\n            </li>\n          </ul>\n          <br />\n          <button onClick={() => this.props.handleSetMaze()}>作成</button>\n          <br />\n          <button onClick={() => this.props.closeModalWindow()}>閉じる</button>\n        </Modal>\n      </div>\n    );\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport { createSlice, configureStore } from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nconst DEFAULTSIZE = 10;\nconst DEFAULTMODE = 1;\n\nconst X = 0;\nconst Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.Key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (state.xIndex === 0) {\n    return false;\n  }\n  return true;\n};\n\nconst setStart = (state, key) => {\n  if (state.timerState === \"\" && key === \"ArrowUp\") {\n    return true;\n  }\n  return false;\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: false,\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: null,\n  timerState: \"\",\n};\n\nexport const currentState = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        goal: setGoal(state.size, state.mode, newAnswerData),\n      };\n    },\n    openWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state, action.payload);\n      if (!movable) {\n        return state;\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n      };\n    },\n    useTimer: (state, action) => {\n      const updateTimer = () => {\n        const time = state.time + 1;\n        const minutes = parseInt((time / 100 / 60) % 100, 10);\n        const seconds = parseInt((time / 100) % 60, 10);\n        const milliSeconds = parseInt(time % 100, 10);\n        return {\n          minutes: toText(minutes),\n          seconds: toText(seconds),\n          milliSeconds: toText(milliSeconds),\n          time: time,\n        };\n      };\n      const key = action.payload;\n      const startTimer = () => {\n        state.timer = setInterval(updateTimer, 10);\n        return {\n          timerState: \"start\",\n        };\n      };\n      const stopTimer = () => {\n        clearInterval(state.timer);\n        return {\n          timerState: \"stop\",\n        };\n      };\n      if (setStart(state, key)) {\n        startTimer();\n      }\n      if (state.xIndex === 0) {\n        stopTimer();\n      }\n      return {\n        ...state,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  reducer: currentState.reducer,\n});\n","import ModalWindow from \"./ModalWindow\";\nimport { currentState } from \"./Reducers\";\nimport { connect } from \"react-redux\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleSizeChange: (size) => {\n      dispatch(currentState.actions.sizeChange(Number(size)));\n    },\n    handleModeChange: (mode) => {\n      dispatch(currentState.actions.modeChange(Number(mode)));\n    },\n    handleSetMaze: () => {\n      dispatch(currentState.actions.setMaze());\n    },\n    openModalWindow: () => {\n      dispatch(currentState.actions.openWindow(true));\n    },\n    closeModalWindow: () => {\n      dispatch(currentState.actions.closeWindow(false));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ModalWindow);\n","import React from \"react\";\n\nclass Timer extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.handleTimerUse(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.handleTimerUse(event.key)\n    );\n  };\n\n  render() {\n    return (\n      <div\n        className=\"timer\"\n        onKeyDown={(event) => this.props.handleTimerUse(event.key)}\n      >\n        <h5>〈〈 Timer 〉〉</h5>\n        <div id=\"showTimer\">\n          <h5>\n            {this.props.minutes} : {this.props.seconds} :{\" \"}\n            {this.props.milliSeconds}\n          </h5>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Timer;\n","import Timer from \"./Timer\";\nimport { connect } from \"react-redux\";\nimport { currentState } from \"./Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleTimerUse: (key) => {\n      dispatch(currentState.actions.useTimer(key));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Timer);\n","import React from \"react\";\n\nconst rowStyle = {\n  height: 12,\n};\n\nconst roadStyle = {\n  width: 12,\n  height: 12,\n  border: \"solid 1px gray\",\n  display: \"inline-block\",\n  boxsizing: \"border-box\",\n  lineheight: \"12px\",\n};\n\nconst X = 0;\nconst Y = 1;\n\nclass Show extends React.Component {\n  componentDidMount = () => {\n    document.addEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n  componentWillUnmount = () => {\n    document.removeEventListener(\"keydown\", (event) =>\n      this.props.keyDownAction(event.key)\n    );\n  };\n\n  render() {\n    const data = this.props.data;\n    const answerData = this.props.answerData;\n    const movePoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.xIndex && colIndex === this.props.yIndex) {\n        return true;\n      }\n      return false;\n    };\n\n    const goalPoint = (rowIndex, colIndex) => {\n      if (rowIndex === this.props.goal[X] && colIndex === this.props.goal[Y]) {\n        return true;\n      }\n      return false;\n    };\n\n    const showAnswer = (rowIndex, colIndex, answerShow) => {\n      if (answerShow === false) {\n        return goalPoint(rowIndex, colIndex) ? true : false;\n      }\n      for (\n        let answerIndex = 0;\n        answerIndex < answerData.length;\n        answerIndex++\n      ) {\n        if (\n          answerData[answerIndex][X] === rowIndex &&\n          answerData[answerIndex][Y] === colIndex\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    return (\n      <div\n        className=\"Show\"\n        onKeyDown={(event) => this.props.keyDownAction(event.key)}\n      >\n        <div>\n          {data.map((row, rowIndex) => {\n            return (\n              <div style={rowStyle} key={`row:${rowIndex}`}>\n                {row.map((point, colIndex) => {\n                  const road = point;\n                  return (\n                    <button\n                      key={`row:${rowIndex},col:${colIndex}`}\n                      className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                      // スタイルの実装を考え直せ\n                      style={{\n                        ...roadStyle,\n                        backgroundColor: road\n                          ? showAnswer(\n                              rowIndex,\n                              colIndex,\n                              this.props.answerShow\n                            )\n                            ? \"skyblue\"\n                            : \"\"\n                          : \"black\",\n                      }}\n                    ></button>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <h4>\n          モード {this.props.mode}\n          <br />\n          迷路サイズは {this.props.size} × {this.props.size} です\n        </h4>\n        <button\n          className=\"answerbutton\"\n          onClick={() => this.props.handleShowAnswer()}\n        >\n          迷路の解答\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default Show;\n","import Show from \"./Show\";\nimport { connect } from \"react-redux\";\nimport { currentState } from \"./Reducers\";\n\nconst mapStateToProps = (state) => {\n  return state;\n};\n\nconst X = 0;\nconst Y = 1;\n\nconst keyArray = {\n  ArrowUp: [-1, 0],\n  ArrowRight: [0, 1],\n  ArrowDown: [1, 0],\n  ArrowLeft: [0, -1],\n};\n\nconst getPayload = (key) => {\n  let direction = [];\n  if (Object.keys(keyArray).includes(key)) {\n    direction = keyArray[key];\n  } else {\n    direction = [0, 0];\n  }\n  const nextPoint = direction;\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    Key: key,\n  };\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    keyDownAction: (key) => {\n      const payload = getPayload(key);\n      dispatch(currentState.actions.movePoint(payload));\n    },\n    handleShowAnswer: () => {\n      dispatch(currentState.actions.showAnswer(true));\n    },\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Show);\n","import React from \"react\";\nimport Header from \"./Header\";\nimport SelectContainer from \"./SelectContainer\";\nimport TimerContainer from \"./TimerContainer\";\nimport ShowContainer from \"./ShowContainer\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <SelectContainer />\n        <TimerContainer />\n        <ShowContainer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./Reducers\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}