{"version":3,"sources":["components/Header.js","modules/Maze.js","modules/MazeAnswer.js","modules/Modules.js","hooks/useSelectMenu.js","components/SizeSelect.js","components/ModeSelect.js","components/Buttons.js","components/ModalSelect.js","hooks/useTimer.js","components/TimerDisplay.js","components/Timer.js","hooks/useKeyBoard.js","components/Show.js","hooks/useSPButton.js","components/SPDisplay.js","components/App.js","reportWebVitals.js","index.js"],"names":["HeaderStyle","styled","header","Header","DIRECTIONS","Maze","size","this","xSize","ySize","maze","Array","xIndex","yIndex","edgeArray","direction","nextXIndex","nextYIndex","judgeEdge","digableDirections","judgeCount","observingDirectionIndex","excludeDirection","judgeDirections","push","getMovableDirections","length","isDigable","digableDirection","nextPoint","hasDigableRoads","directions","Math","floor","random","digRoad","nextRestartPoint","getRestartPoint","candidateRestartPoint","mode","GOAL","createMaze","result","digMaze","Number","MazeAnswer","mazeSize","mazeData","startPoint","verifyPoint","availableRoads","routes","meetingTermsRoute","routesPattern","routeIndex","getMeetingTermsRoute","slice","branchPoints","branchPointIndex","getAvailableRoads","retensionRoute","getRouteToBranch","hasRoads","branchPoint","getBranchPoint","getStartPoint","getRoutes","copyMaze","JSON","parse","stringify","REACHMODESTART","REACHOMODEGOAL","allRoutes","pattern","answerReachRoute","answerLongestRoute","getKeyArray","key","digGoal","mazeAnswerData","getAnswerRoute","setTimerState","state","goal","answerShow","start","toText","time","initialState","data","answerData","isModalOpen","DEFAULTSIZE","movable","minutes","seconds","milliSeconds","timer","intervalID","squareLength","mazeSlice","createSlice","name","reducers","sizeChange","action","payload","modeChange","setMaze","newMazeData","newAnswerData","clearInterval","openWindow","closeWindow","movePoint","switchMovable","nextX","nextY","isAvailable","showAnswer","startTimer","updateTimer","parseInt","store","configureStore","reducer","useSelectMenu","useSelector","dispatch","useDispatch","handleSetMaze","actions","update","setInterval","handleShowAnswer","closeModalWindow","getState","close","resume","handleModeChange","handleSizeChange","openModalWindow","SizeSelect","InputLabel","Select","onChange","event","target","value","displayEmpty","MenuItem","disabled","ModeSelect","Buttons","Wrapper","Button","color","variant","onClick","style","margin","div","windowStyle","content","top","left","right","bottom","marginRight","transform","Modal","setAppElement","ModalSelect","MenuWrapper","isOpen","onRequestClose","contentLabel","overlayClassName","useTimer","TimeStyle","h5","TimerDisplay","props","TimerWrapper","Timer","useKeyBoard","keyDownAction","getPayload","rowIndex","colIndex","goalPoint","answerIndex","MazeWrapper","height","Show","element","useRef","useState","setLength","useEffect","current","clientWidth","document","addEventListener","removeEventListener","sideLength","rowStyle","padding","roadStyle","width","lineheight","border","display","ref","map","row","point","road","className","backgroundColor","useSPButton","buttonAction","SPDisplayWrapper","ButtonWrapper","UpButton","RightButton","DownButton","LeftButton","SPDisplay","query","onPointerDown","AppWrapper","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.59955ae4.chunk.js","sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\n\nconst Header = () => {\n  return <HeaderStyle>迷路ゲーム</HeaderStyle>;\n};\n\nconst HeaderStyle = styled.header`\n  border-bottom: solid 1px #ccc;\n  font-size: 1.8rem;\n  color: #000044;\n  background-color: #ccc;\n  padding-bottom: 20px;\n  margin-bottom: 10px;\n`;\n\nexport default Header;\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class Maze {\n  constructor(size) {\n    this.xSize = size;\n    this.ySize = size;\n  }\n\n  createMaze() {\n    const maze = new Array(this.xSize);\n    for (let xIndex = 0; xIndex < this.xSize; xIndex++) {\n      maze[xIndex] = new Array(this.ySize);\n      for (let yIndex = 0; yIndex < this.ySize; yIndex++) {\n        maze[xIndex][yIndex] = false;\n      }\n    }\n    maze[this.xSize - 2][1] = true;\n    return maze;\n  }\n\n  judgeEdge(xIndex, yIndex) {\n    const edgeArray = [0, this.ySize - 1, this.xSize - 1, 0];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      if (\n        (direction % 2 === 0 && xIndex === edgeArray[direction]) ||\n        (direction % 2 === 1 && yIndex === edgeArray[direction])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  judgeDirections(xIndex, yIndex, direction, maze) {\n    const nextXIndex = xIndex + DIRECTIONS[direction][X];\n    const nextYIndex = yIndex + DIRECTIONS[direction][Y];\n    if (\n      maze[nextXIndex][nextYIndex] === false &&\n      this.judgeEdge(nextXIndex, nextYIndex)\n    ) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * ある地点の座標について, その地点からまだ進める方向を格納した配列を返す\n   * @param  xIndex その時点でのx座標\n   * @param  yIndex その時点でのy座標\n   * @param  maze 迷路の配列\n   * @returns 配列(進める方向)\n   */\n  getMovableDirections(xIndex, yIndex, maze) {\n    const digableDirections = [];\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      let judgeCount = 0;\n      for (\n        let observingDirectionIndex = 0;\n        observingDirectionIndex < DIRECTION;\n        observingDirectionIndex++\n      ) {\n        let excludeDirection = (observingDirectionIndex + 2) % 4;\n        if (this.judgeDirections(xIndex, yIndex, direction, maze)) {\n          let nextXIndex =\n            xIndex + DIRECTIONS[direction][X] + DIRECTIONS[excludeDirection][X];\n          let nextYIndex =\n            yIndex + DIRECTIONS[direction][Y] + DIRECTIONS[excludeDirection][Y];\n          if (!maze[nextXIndex][nextYIndex]) {\n            judgeCount++;\n          }\n        }\n      }\n      if (judgeCount === 3) {\n        digableDirections.push(direction);\n      }\n    }\n    return digableDirections;\n  }\n\n  isDigable(xIndex, yIndex, maze) {\n    if (\n      maze[xIndex][yIndex] &&\n      this.getMovableDirections(xIndex, yIndex, maze).length !== 0\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  hasDigableRoads(maze) {\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (this.isDigable(xIndex, yIndex, maze)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  digRoad(xIndex, yIndex, digableDirection, maze) {\n    const nextPoint = [];\n    nextPoint[X] = xIndex + DIRECTIONS[digableDirection][X];\n    nextPoint[Y] = yIndex + DIRECTIONS[digableDirection][Y];\n    maze[nextPoint[X]][nextPoint[Y]] = true;\n    return nextPoint;\n  }\n\n  digMaze(maze) {\n    let xIndex = this.xSize - 2;\n    let yIndex = 1;\n    while (this.hasDigableRoads(maze)) {\n      const directions = this.getMovableDirections(xIndex, yIndex, maze);\n      if (directions.length > 0) {\n        const digableDirection = Math.floor(Math.random() * directions.length);\n        const nextPoint = this.digRoad(\n          xIndex,\n          yIndex,\n          directions[digableDirection],\n          maze\n        );\n        if (nextPoint.length > 0) {\n          xIndex = nextPoint[X];\n          yIndex = nextPoint[Y];\n        }\n      } else if (directions.length === 0) {\n        const nextRestartPoint = this.getRestartPoint(maze);\n        if (nextRestartPoint !== 0) {\n          xIndex = nextRestartPoint[X];\n          yIndex = nextRestartPoint[Y];\n        }\n      }\n    }\n    return maze;\n  }\n\n  getRestartPoint(maze) {\n    const nextRestartPoint = [];\n    for (let xIndex = 1; xIndex < this.xSize - 1; xIndex++) {\n      for (let yIndex = 1; yIndex < this.ySize - 1; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          if (this.getMovableDirections(xIndex, yIndex, maze).length > 0) {\n            let candidateRestartPoint = [xIndex, yIndex];\n            nextRestartPoint.push(candidateRestartPoint);\n            break;\n          }\n        }\n      }\n    }\n    if (nextRestartPoint.length > 0) {\n      const restartPointIndex = Math.floor(\n        Math.random() * nextRestartPoint.length\n      );\n      return nextRestartPoint[restartPointIndex];\n    }\n    return 0;\n  }\n\n  digGoal(mode) {\n    const GOAL = [1, this.ySize - 2];\n    let maze = this.createMaze();\n    let result = this.digMaze(maze);\n    while (!maze[GOAL[X]][GOAL[Y]]) {\n      maze = this.createMaze();\n      result = this.digMaze(maze);\n    }\n    result[this.xSize - 1][1] = true;\n    if (Number(mode) === REACHMODE) {\n      result[0][this.ySize - 2] = true;\n    }\n    return result;\n  }\n}\n","const DIRECTION = 4;\n\nconst X = 0;\nconst Y = 1;\n\nconst REACHMODE = 1;\nconst LONGESTMODE = 2;\n\nconst DIRECTIONS = [\n  [0, -1],\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n];\n\nexport default class MazeAnswer {\n  constructor(maze) {\n    this.mazeSize = maze.length;\n    this.mazeData = maze;\n  }\n\n  getAvailableRoads(maze, startPoint) {\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        startPoint[X] + DIRECTIONS[direction][X],\n        startPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        return nextPoint;\n      }\n    }\n    return false;\n  }\n\n  hasRoads(maze) {\n    for (let xIndex = 0; xIndex < this.mazeSize; xIndex++) {\n      for (let yIndex = 0; yIndex < this.mazeSize; yIndex++) {\n        if (maze[xIndex][yIndex]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  getBranchPoint(maze, verifyPoint) {\n    if (verifyPoint === false) {\n      return false;\n    }\n    let availableRoads = 0;\n    for (let direction = 0; direction < DIRECTION; direction++) {\n      const nextPoint = [\n        verifyPoint[X] + DIRECTIONS[direction][X],\n        verifyPoint[Y] + DIRECTIONS[direction][Y],\n      ];\n      if (maze[nextPoint[X]][nextPoint[Y]]) {\n        availableRoads++;\n      }\n    }\n    return availableRoads > 1 ? verifyPoint : false;\n  }\n\n  getMeetingTermsRoute(routes, startPoint) {\n    let meetingTermsRoute = routes[0];\n    for (\n      let routesPattern = 1;\n      routesPattern < routes.length;\n      routesPattern++\n    ) {\n      for (\n        let routeIndex = 0;\n        routeIndex < routes[routesPattern].length;\n        routeIndex++\n      ) {\n        if (routes[routesPattern][routeIndex] === startPoint) {\n          meetingTermsRoute = routes[routesPattern];\n        }\n      }\n    }\n    return meetingTermsRoute;\n  }\n\n  getRouteToBranch(startPoint, routes) {\n    if (routes.length === 0) {\n      return [startPoint];\n    }\n    const meetingTermsRoute = this.getMeetingTermsRoute(routes, startPoint);\n    for (\n      let routeIndex = meetingTermsRoute.length - 1;\n      routeIndex >= 0;\n      routeIndex--\n    ) {\n      if (meetingTermsRoute[routeIndex] === startPoint) {\n        return meetingTermsRoute.slice(0, routeIndex + 1);\n      }\n    }\n    return [startPoint];\n  }\n\n  getStartPoint(maze, branchPoints) {\n    for (\n      let branchPointIndex = branchPoints.length - 1;\n      branchPointIndex >= 0;\n      branchPointIndex--\n    ) {\n      if (\n        this.getAvailableRoads(maze, branchPoints[branchPointIndex]) !== false\n      ) {\n        return branchPoints[branchPointIndex];\n      }\n    }\n  }\n\n  getRoutes(maze, startPoint, routes, branchPoints) {\n    const retensionRoute = this.getRouteToBranch(startPoint, routes);\n    while (this.hasRoads(maze)) {\n      const nextPoint = this.getAvailableRoads(maze, startPoint);\n      const branchPoint = this.getBranchPoint(maze, startPoint);\n      if (branchPoint !== false) {\n        branchPoints.push(branchPoint);\n      }\n      maze[startPoint[X]][startPoint[Y]] = false;\n      if (nextPoint === false) {\n        if (retensionRoute.length !== 0) {\n          routes.push(retensionRoute);\n        }\n        startPoint = this.getStartPoint(maze, branchPoints);\n        return this.getRoutes(maze, startPoint, routes, branchPoints);\n      }\n      retensionRoute.push(nextPoint);\n      startPoint = nextPoint;\n    }\n    return routes;\n  }\n\n  getAnswerRoute(mode) {\n    const copyMaze = JSON.parse(JSON.stringify(this.mazeData));\n    copyMaze[this.mazeSize - 1][1] = false;\n    copyMaze[0][this.mazeSize - 2] = false;\n    const REACHMODESTART = [this.mazeSize - 2, 1];\n    const REACHOMODEGOAL = [0, this.mazeSize - 2];\n    const routes = [];\n    const branchPoints = [];\n    const allRoutes = this.getRoutes(\n      copyMaze,\n      REACHMODESTART,\n      routes,\n      branchPoints\n    );\n\n    if (Number(mode) === REACHMODE) {\n      for (let pattern = 0; pattern < allRoutes.length; pattern++) {\n        for (\n          let routeIndex = 0;\n          routeIndex < allRoutes[pattern].length;\n          routeIndex++\n        ) {\n          if (\n            allRoutes[pattern][routeIndex][X] === REACHOMODEGOAL[X] + 1 &&\n            allRoutes[pattern][routeIndex][Y] === REACHOMODEGOAL[Y]\n          ) {\n            const answerReachRoute = allRoutes[pattern].slice(\n              0,\n              routeIndex + 1\n            );\n            answerReachRoute.push(REACHOMODEGOAL);\n            return answerReachRoute;\n          }\n        }\n      }\n    }\n\n    if (Number(mode) === LONGESTMODE) {\n      let answerLongestRoute = allRoutes[0];\n      for (let pattern = 1; pattern < allRoutes.length; pattern++) {\n        if (answerLongestRoute.length < allRoutes[pattern].length) {\n          answerLongestRoute = allRoutes[pattern];\n        }\n      }\n      return answerLongestRoute;\n    }\n  }\n}\n","import Maze from \"./Maze\";\nimport MazeAnswer from \"./MazeAnswer\";\nimport { createSlice, configureStore } from \"@reduxjs/toolkit\";\n\nconst LONGESTMODE = 2;\n\nexport const DEFAULTSIZE = 10;\nexport const DEFAULTMODE = 1;\n\nexport const getKeyArray = (key) => {\n  switch (key) {\n    case \"ArrowUp\":\n      return [-1, 0];\n    case \"ArrowRight\":\n      return [0, 1];\n    case \"ArrowDown\":\n      return [1, 0];\n    case \"ArrowLeft\":\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n};\n\nexport const X = 0;\nexport const Y = 1;\n\nconst maze = new Maze(DEFAULTSIZE);\nconst mazeData = maze.digGoal(DEFAULTMODE);\nconst mazeAnswer = new MazeAnswer(mazeData);\nconst mazeAnswerData = mazeAnswer.getAnswerRoute(DEFAULTMODE);\n\nconst isAvailable = (state, payload) => {\n  if (state.xIndex === state.size - 1 && payload.key !== \"ArrowUp\") {\n    return [state.xIndex, state.yIndex];\n  }\n  const nextPoint = [\n    state.xIndex + payload.nextX,\n    state.yIndex + payload.nextY,\n  ];\n  if (!state.data[nextPoint[X]][nextPoint[Y]]) {\n    return [state.xIndex, state.yIndex];\n  }\n  return nextPoint;\n};\n\nconst setGoal = (size, mode, answerData) => {\n  if (mode === LONGESTMODE) {\n    const longestModeGoal = [\n      answerData.slice(-1)[0][X],\n      answerData.slice(-1)[0][Y],\n    ];\n    return longestModeGoal;\n  }\n  return [0, size - 2];\n};\n\nconst switchMovable = (state) => {\n  if (\n    (state.xIndex === state.goal[X] && state.yIndex === state.goal[Y]) ||\n    state.isModalOpen === true\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst setTimerState = (state) => {\n  if (\n    (state.goal[X] === state.xIndex && state.goal[Y] === state.yIndex) ||\n    state.answerShow === true\n  ) {\n    return \"finish\";\n  }\n\n  return state.xIndex === state.start[X] && state.yIndex === state.start[Y]\n    ? \"stop\"\n    : \"start\";\n};\n\nconst toText = (time) => {\n  return (\"000\" + time).slice(-3);\n};\n\nconst initialState = {\n  size: DEFAULTSIZE,\n  mode: DEFAULTMODE,\n  data: mazeData,\n  answerData: mazeAnswerData,\n  answerShow: false,\n  isModalOpen: true,\n  start: [DEFAULTSIZE - 1, 1],\n  goal: [0, DEFAULTSIZE - 2],\n  movable: false,\n  xIndex: DEFAULTSIZE - 1,\n  yIndex: 1,\n  minutes: \"000\",\n  seconds: \"000\",\n  milliSeconds: \"000\",\n  time: 0,\n  timer: \"stop\",\n  intervalID: -1,\n  squareLength: 500,\n};\n\nexport const mazeSlice = createSlice({\n  name: \"mazeState\",\n  initialState,\n  reducers: {\n    sizeChange: (state, action) => {\n      return {\n        ...state,\n        size: action.payload,\n      };\n    },\n    modeChange: (state, action) => {\n      return {\n        ...state,\n        mode: action.payload,\n      };\n    },\n    setMaze: (state) => {\n      const newMaze = new Maze(state.size);\n      const newMazeData = newMaze.digGoal(state.mode);\n      const newAnswer = new MazeAnswer(newMazeData);\n      const newAnswerData = newAnswer.getAnswerRoute(state.mode);\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        data: newMazeData,\n        answerData: newAnswerData,\n        isModalOpen: false,\n        answerShow: false,\n        xIndex: state.size - 1,\n        yIndex: 1,\n        start: [state.size - 1, 1],\n        goal: setGoal(state.size, state.mode, newAnswerData),\n        minutes: \"000\",\n        seconds: \"000\",\n        milliSeconds: \"000\",\n        time: 0,\n        timer: \"stop\",\n        intervalID: -1,\n      };\n    },\n    openWindow: (state, action) => {\n      clearInterval(state.intervalID);\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    closeWindow: (state, action) => {\n      return {\n        ...state,\n        isModalOpen: action.payload,\n        timer: setTimerState(state),\n      };\n    },\n    movePoint: (state, action) => {\n      const movable = switchMovable(state);\n      if (!movable) {\n        clearInterval(state.intervalID);\n        return {\n          ...state,\n        };\n      }\n      const nextPoint = isAvailable(state, action.payload);\n      if (nextPoint[X] === state.goal[X] && nextPoint[Y] === state.goal[Y]) {\n        clearInterval(state.intervalID);\n        return {\n          ...state,\n          xIndex: nextPoint[X],\n          yIndex: nextPoint[Y],\n          movable: movable,\n          intervalID: -1,\n          timer: \"finish\",\n        };\n      }\n      return {\n        ...state,\n        xIndex: nextPoint[X],\n        yIndex: nextPoint[Y],\n        movable: movable,\n      };\n    },\n    showAnswer: (state, action) => {\n      return {\n        ...state,\n        answerShow: action.payload,\n        isModalOpen: false,\n      };\n    },\n    startTimer: (state, action) => {\n      return {\n        ...state,\n        intervalID: action.payload,\n        timer: \"start\",\n      };\n    },\n    updateTimer: (state) => {\n      const time = state.time + 1;\n      const minutes = parseInt((time / 100 / 60) % 100, 10);\n      const seconds = parseInt((time / 100) % 60, 10);\n      const milliSeconds = parseInt(time % 100, 10);\n      return {\n        ...state,\n        minutes: toText(minutes),\n        seconds: toText(seconds),\n        milliSeconds: toText(milliSeconds),\n        time: time,\n      };\n    },\n  },\n});\n\nexport const store = configureStore({\n  reducer: mazeSlice.reducer,\n});\n","import { mazeSlice, store } from \"../modules/Modules\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nconst useSelectMenu = () => {\n  const { size, mode, isModalOpen, timer } = useSelector((state) => state);\n  const dispatch = useDispatch();\n\n  const handleSizeChange = (size) => {\n    const sizeChange = mazeSlice.actions.sizeChange(Number(size));\n    dispatch(sizeChange);\n  };\n\n  const handleModeChange = (mode) => {\n    const modeChange = mazeSlice.actions.modeChange(Number(mode));\n    dispatch(modeChange);\n  };\n\n  const handleSetMaze = () => {\n    const setMaze = mazeSlice.actions.setMaze();\n    const update = mazeSlice.actions.updateTimer();\n    const intervalID = setInterval(() => dispatch(update), 10);\n    const start = mazeSlice.actions.startTimer(intervalID);\n    dispatch(setMaze);\n    dispatch(start);\n  };\n\n  const openModalWindow = () => {\n    const openWindow = mazeSlice.actions.openWindow(true);\n    dispatch(openWindow);\n  };\n\n  const closeModalWindow = () => {\n    const { timer } = store.getState();\n    const close = timer === \"stop\" ? true : false;\n    const closeWindow = mazeSlice.actions.closeWindow(close);\n    dispatch(closeWindow);\n\n    if (timer === \"start\" || timer === \"pause\") {\n      const update = mazeSlice.actions.updateTimer();\n      const intervalID = setInterval(() => dispatch(update), 10);\n      const resume = mazeSlice.actions.startTimer(intervalID);\n      dispatch(resume);\n    }\n  };\n\n  const handleShowAnswer = () => {\n    const showAnswer = mazeSlice.actions.showAnswer(true);\n    dispatch(showAnswer);\n  };\n\n  return {\n    size,\n    mode,\n    isModalOpen,\n    timer,\n    handleSetMaze,\n    handleShowAnswer,\n    closeModalWindow,\n    handleModeChange,\n    handleSizeChange,\n    openModalWindow,\n  };\n};\n\nexport default useSelectMenu;\n","import React from \"react\";\nimport { Select, MenuItem, InputLabel } from \"@material-ui/core\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\n\nconst SizeSelect = () => {\n  const { size, handleSizeChange } = useSelectMenu();\n\n  return (\n    <div>\n      <InputLabel>size</InputLabel>\n      <Select\n        onChange={(event) => handleSizeChange(event.target.value)}\n        value={size}\n        displayEmpty\n      >\n        <MenuItem value={\"\"} disabled>\n          <em>サイズを選択してください</em>\n        </MenuItem>\n        <MenuItem value={10}>10 × 10</MenuItem>\n        <MenuItem value={20}>20 × 20</MenuItem>\n        <MenuItem value={30}>30 × 30</MenuItem>\n        <MenuItem value={40}>40 × 40</MenuItem>\n        <MenuItem value={50}>50 × 50</MenuItem>\n      </Select>\n    </div>\n  );\n};\n\nexport default SizeSelect;\n","import React from \"react\";\nimport { Select, MenuItem, InputLabel } from \"@material-ui/core\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\n\nconst ModeSelect = () => {\n  const { mode, handleModeChange } = useSelectMenu();\n\n  return (\n    <div>\n      <InputLabel>mode</InputLabel>\n      <Select\n        onChange={(event) => handleModeChange(event.target.value)}\n        value={mode}\n        displayEmpty\n      >\n        <MenuItem value={\"\"} disabled>\n          <em>モードを選択してください</em>\n        </MenuItem>\n        <MenuItem value={1}>到達モード</MenuItem>\n        <MenuItem value={2}>最長モード</MenuItem>\n      </Select>\n    </div>\n  );\n};\n\nexport default ModeSelect;\n","import React from \"react\";\nimport { Button } from \"@material-ui/core\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\nimport styled from \"styled-components\";\n\nconst Buttons = () => {\n  const { timer, handleSetMaze, handleShowAnswer, closeModalWindow } =\n    useSelectMenu();\n  if (timer !== \"stop\") {\n    return (\n      <Wrapper>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          onClick={() => handleSetMaze()}\n          style={{ margin: 5 }}\n        >\n          再生成＆スタート\n        </Button>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          onClick={() => handleShowAnswer()}\n          style={{ margin: 5 }}\n        >\n          解答\n        </Button>\n        <Button\n          color=\"primary\"\n          variant=\"contained\"\n          onClick={() => closeModalWindow()}\n          style={{ margin: 5 }}\n        >\n          閉じる\n        </Button>\n      </Wrapper>\n    );\n  }\n\n  return (\n    <Button color=\"primary\" variant=\"contained\" onClick={() => handleSetMaze()}>\n      生成{\"&\"}スタート\n    </Button>\n  );\n};\n\nexport default Buttons;\n\nconst Wrapper = styled.div`\n  width: 100%;\n`;\n","import React from \"react\";\nimport Modal from \"react-modal\";\nimport styled from \"styled-components\";\nimport Button from \"@material-ui/core/Button\";\nimport useSelectMenu from \"../hooks/useSelectMenu\";\nimport SizeSelect from \"./SizeSelect\";\nimport ModeSelect from \"./ModeSelect\";\nimport Buttons from \"./Buttons\";\n\nconst windowStyle = {\n  content: {\n    top: \"50%\",\n    left: \"50%\",\n    right: \"auto\",\n    bottom: \"auto\",\n    marginRight: \"-50%\",\n    transform: \"translate(-50%, -50%)\",\n  },\n};\n\nModal.setAppElement(\"#root\");\nconst ModalSelect = () => {\n  const { size, mode, isModalOpen, openModalWindow, closeModalWindow } =\n    useSelectMenu();\n\n  return (\n    <MenuWrapper>\n      <Button\n        variant=\"contained\"\n        color=\"primary\"\n        onClick={() => openModalWindow()}\n      >\n        menu\n      </Button>\n      <Modal\n        isOpen={isModalOpen}\n        onRequestClose={() => closeModalWindow()}\n        style={windowStyle}\n        contentLabel=\"EXAMPLE\"\n        overlayClassName=\"overlay\"\n      >\n        <h3>迷路オプション</h3>\n        <p> 迷路サイズ・モードを選択してください </p>\n        <SizeSelect />\n        <ModeSelect />\n        <br />\n        <h4>\n          現在の迷路サイズは{size} × {size}\n        </h4>\n        <h4>{mode === 1 ? \"到達\" : \"最長\"} モードです</h4>\n        <br />\n        <Buttons />\n      </Modal>\n    </MenuWrapper>\n  );\n};\n\nexport default ModalSelect;\n\nconst MenuWrapper = styled.div`\n  padding-top: 5px;\n`;\n","import { useSelector } from \"react-redux\";\n\nconst useTimer = () => {\n  const { minutes, seconds, milliSeconds } = useSelector((state) => state);\n\n  return {\n    minutes,\n    seconds,\n    milliSeconds,\n  };\n};\n\nexport default useTimer;\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nconst TimerDisplay = (props) => {\n  const { minutes, seconds, milliSeconds } = props;\n  return (\n    <Wrapper>\n      <TimeStyle>{minutes} : </TimeStyle>\n      <TimeStyle>{seconds} : </TimeStyle>\n      <TimeStyle>{milliSeconds}</TimeStyle>\n    </Wrapper>\n  );\n};\n\nconst Wrapper = styled.div`\n  flex-wrap: unwrap;\n`;\n\nconst TimeStyle = styled.h5`\n  display: inline-block;\n  font-size: 20px;\n  color: #000055;\n  padding-top: 1rem;\n  margin: 5px;\n`;\n\nexport default TimerDisplay;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport useTimer from \"../hooks/useTimer\";\nimport TimerDisplay from \"./TimerDisplay\";\n\nconst Timer = () => {\n  const { minutes, seconds, milliSeconds } = useTimer();\n\n  return (\n    <TimerWrapper>\n      <TimerDisplay\n        minutes={minutes}\n        seconds={seconds}\n        milliSeconds={milliSeconds}\n      />\n    </TimerWrapper>\n  );\n};\n\nconst TimerWrapper = styled.div`\n  display: flex;\n  justify-content: center;\n`;\n\nexport default Timer;\n","import { mazeSlice, getKeyArray, X, Y } from \"../modules/Modules\";\nimport { useSelector, useDispatch } from \"react-redux\";\n\nconst getPayload = (key) => {\n  const nextPoint = getKeyArray(key);\n  return {\n    nextX: nextPoint[X],\n    nextY: nextPoint[Y],\n    key: key,\n  };\n};\n\nconst useKeyBoard = () => {\n  const { size, data, answerData, answerShow, xIndex, yIndex, goal } =\n    useSelector((state) => state);\n\n  const dispatch = useDispatch();\n\n  const movePoint = (rowIndex, colIndex) => {\n    if (rowIndex === xIndex && colIndex === yIndex) {\n      return true;\n    }\n    return false;\n  };\n\n  const goalPoint = (rowIndex, colIndex) => {\n    if (rowIndex === goal[X] && colIndex === goal[Y]) {\n      return true;\n    }\n    return false;\n  };\n\n  const showAnswer = (rowIndex, colIndex) => {\n    if (answerShow === false) {\n      return goalPoint(rowIndex, colIndex) ? true : false;\n    }\n    for (let answerIndex = 0; answerIndex < answerData.length; answerIndex++) {\n      if (\n        answerData[answerIndex][X] === rowIndex &&\n        answerData[answerIndex][Y] === colIndex\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const keyDownAction = (key) => {\n    const payload = getPayload(key);\n    const movePoint = mazeSlice.actions.movePoint(payload);\n    dispatch(movePoint);\n  };\n  return {\n    data,\n    size,\n    keyDownAction,\n    movePoint,\n    showAnswer,\n  };\n};\n\nexport default useKeyBoard;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport useKeyBoard from \"../hooks/useKeyBoard\";\nimport styled from \"styled-components\";\nimport Timer from \"./Timer\";\n\nconst Show = () => {\n  const { data, size, keyDownAction, movePoint, showAnswer } = useKeyBoard();\n  const element = useRef(null);\n  const [length, setLength] = useState(0);\n\n  useEffect(() => {\n    const squareLength = element.current.clientWidth;\n    setLength(squareLength);\n    document.addEventListener(\"keydown\", (event) => {\n      keyDownAction(event.key);\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", (event) => {\n        keyDownAction(event.key);\n      });\n    };\n  }, []);\n\n  const sideLength = length / size;\n  const rowStyle = {\n    padding: 0,\n    height: sideLength,\n  };\n  const roadStyle = {\n    padding: 0,\n    width: sideLength,\n    height: sideLength,\n    lineheight: sideLength,\n    border: \"none\",\n    display: \"inline-block\",\n    // boxsizing: \"border-box\",\n  };\n\n  return (\n    <Wrapper>\n      <Timer />\n      <MazeWrapper ref={element} height={length}>\n        {data.map((row, rowIndex) => {\n          return (\n            <div style={rowStyle} key={`row:${rowIndex}`}>\n              {row.map((point, colIndex) => {\n                const road = point;\n                return (\n                  <button\n                    key={`row:${rowIndex},col:${colIndex}`}\n                    className={movePoint(rowIndex, colIndex) ? \"move\" : \"\"}\n                    style={{\n                      ...roadStyle,\n                      backgroundColor: road\n                        ? showAnswer(rowIndex, colIndex)\n                          ? \"skyblue\"\n                          : \"\"\n                        : \"black\",\n                    }}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </MazeWrapper>\n    </Wrapper>\n  );\n};\n\nconst Wrapper = styled.div`\n  width: 100%;\n  height: 100%;\n`;\n\nconst MazeWrapper = styled.div`\n  position: absolute;\n  top: 160px;\n  left: 50%;\n  transform: translateX(-50%);\n  min-width: 40%;\n  height: ${(props) => props.height}px;\n`;\n\nexport default Show;\n","import { useDispatch } from \"react-redux\";\nimport { mazeSlice, getKeyArray, X, Y } from \"../modules/Modules\";\n\nconst useSPButton = () => {\n  const dispatch = useDispatch();\n\n  const buttonAction = (key) => {\n    const nextPoint = getKeyArray(key);\n    const payload = {\n      nextX: nextPoint[X],\n      nextY: nextPoint[Y],\n      key: key,\n    };\n    const movePoint = mazeSlice.actions.movePoint(payload);\n    dispatch(movePoint);\n  };\n  return {\n    buttonAction,\n  };\n};\n\nexport default useSPButton;\n","import React from \"react\";\nimport MediaQuery from \"react-responsive\";\nimport useSPButton from \"../hooks/useSPButton\";\nimport styled from \"styled-components\";\n\nconst SPDisplay = () => {\n  const { buttonAction } = useSPButton();\n  return (\n    <SPDisplayWrapper>\n      <MediaQuery query=\"(max-width: 1024px)\">\n        <ButtonWrapper>\n          <UpButton onPointerDown={() => buttonAction(\"ArrowUp\")}></UpButton>\n          <RightButton\n            onPointerDown={() => buttonAction(\"ArrowRight\")}\n          ></RightButton>\n          <DownButton\n            onPointerDown={() => buttonAction(\"ArrowDown\")}\n          ></DownButton>\n          <LeftButton\n            onPointerDown={() => buttonAction(\"ArrowLeft\")}\n          ></LeftButton>\n        </ButtonWrapper>\n      </MediaQuery>\n    </SPDisplayWrapper>\n  );\n};\n\nconst SPDisplayWrapper = styled.div`\n  height: 100%;\n  display: flex;\n  text-align: center;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst ButtonWrapper = styled.div`\n  position: relative;\n  width: 12%;\n  height: 30%;\n  display: flex;\n  justify-content: center;\n  align-self: center;\n`;\n\nconst Button = styled.div`\n  border-right: 25px solid transparent;\n  border-bottom: 50px solid #00ecff;\n  border-left: 25px solid transparent;\n`;\n\nconst UpButton = styled(Button)`\n  position: absolute;\n  top: 0;\n  left: 0;\n`;\n\nconst RightButton = styled(Button)`\n  position: absolute;\n  top: 50px;\n  left: 50px;\n  transform: rotate(90deg);\n`;\n\nconst DownButton = styled(Button)`\n  position: absolute;\n  top: 100px;\n  left: 0px;\n  transform: rotate(180deg);\n`;\n\nconst LeftButton = styled(Button)`\n  position: absolute;\n  top: 50px;\n  left: -50px;\n  transform: rotate(270deg);\n`;\n\nexport default SPDisplay;\n","import React from \"react\";\nimport styled from \"styled-components\";\nimport Header from \"./Header\";\nimport ModalSelect from \"./ModalSelect\";\nimport Timer from \"./Timer\";\nimport Show from \"./Show\";\nimport SPDisplay from \"./SPDisplay\";\nimport \"../App.css\";\n\nconst App = () => {\n  return (\n    <AppWrapper>\n      <Header />\n      <ModalSelect />\n      <Show />\n      <SPDisplay />\n    </AppWrapper>\n  );\n};\n\nconst AppWrapper = styled.div`\n  position: relative;\n  text-align: center;\n  height: 100%;\n  width: 100%;\n`;\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport { Provider } from \"react-redux\";\nimport { store } from \"./modules/Modules\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nreportWebVitals();\n"],"sourceRoot":""}